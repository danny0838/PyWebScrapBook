# @FIXME: Some cases have an unclosed file issue. Although adding
#     buffered=True temporarily suppresses it, a further investigation
#     for a possible leak of the source code is pending.
import io
import json
import os
import shutil
import tempfile
import time
import unittest
from unittest import mock

import webscrapbook
from webscrapbook import WSB_CONFIG, WSB_DIR, WSB_EXTENSION_MIN_VERSION
from webscrapbook import app as wsb_app
from webscrapbook._polyfill import zipfile
from webscrapbook.util import Info
from webscrapbook.util.fs import junction

from . import (
    DUMMY_TS,
    DUMMY_TS2,
    DUMMY_TS3,
    DUMMY_TS4,
    DUMMY_TS5,
    DUMMY_TS7,
    DUMMY_ZIP_DT,
    DUMMY_ZIP_DT2,
    DUMMY_ZIP_DT3,
    DUMMY_ZIP_DT4,
    DUMMY_ZIP_DT5,
    DUMMY_ZIP_DT6,
    DUMMY_ZIP_DT7,
    DUMMY_ZIP_DT8,
    PROG_DIR,
    ROOT_DIR,
    TEMP_DIR,
    TestFileMixin,
    glob_files,
    require_junction,
    require_junction_deletion,
    require_symlink,
)

STATIC_DIR = os.path.join(PROG_DIR, 'themes', 'default', 'static')


def setUpModule():
    # set up a temp directory for testing
    global _tmpdir, tmpdir
    _tmpdir = tempfile.TemporaryDirectory(prefix='actions-', dir=TEMP_DIR)
    tmpdir = os.path.realpath(_tmpdir.name)

    # mock out user config
    global mockings
    mockings = (
        mock.patch('webscrapbook.scrapbook.host.WSB_USER_DIR', os.devnull),
        mock.patch('webscrapbook.WSB_USER_DIR', os.devnull),
        mock.patch('webscrapbook.WSB_USER_CONFIG', os.devnull),
    )
    for mocking in mockings:
        mocking.start()


def tearDownModule():
    """Cleanup the temp directory."""
    _tmpdir.cleanup()

    # stop mock
    for mocking in mockings:
        mocking.stop()


def token(c):
    return c.post('/', data={'a': 'token'}).data.decode('UTF-8')


class TestActions(TestFileMixin, unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # init an app for the class
        cls.root = tempfile.mkdtemp(dir=tmpdir)
        os.rmdir(cls.root)
        shutil.copytree(os.path.join(ROOT_DIR, 'test_app_actions'), cls.root)
        cls.app = wsb_app.make_app(cls.root)
        cls.app.testing = True

    def setUp(self):
        # A subpath to place test-specific files,
        # which will be cleaned during tearDown.
        self.test_dir = os.path.join(self.root, 'deep')
        os.makedirs(self.test_dir)

        self.test_html = os.path.join(self.test_dir, 'temp.html')
        self.test_zip = os.path.join(self.test_dir, 'archive.zip')
        self.test_htz = os.path.join(self.test_dir, 'archive.htz')
        self.test_maff = os.path.join(self.test_dir, 'archive.maff')

    def tearDown(self):
        try:
            shutil.rmtree(os.path.join(self.root, WSB_DIR, 'server', 'tokens'))
        except FileNotFoundError:
            pass
        try:
            shutil.rmtree(os.path.join(self.root, WSB_DIR, 'locks'))
        except FileNotFoundError:
            pass
        try:
            shutil.rmtree(self.test_dir, onerror=self.rmtree_error_handler)
        except FileNotFoundError:
            pass

    def rmtree_error_handler(self, func, path, ex):
        """Error handler for shutil.rmtree.

        Python < 3.8 attempts to remove all contents for a directory junction,
        and will raises a FileNotFoundError if target not exist. Catch it to
        prevent skipping removal of further entries.
        """
        type, value, trace = ex
        if type is not FileNotFoundError:
            raise

    def parse_sse(self, content):
        """Quick parser of SSE.

        The current implementation is not complete, but just enough for parsing
        the SSE generated by our app.

        ref: https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation

        Yields:
            tuple: (event, data)
        """
        event = ''
        data = ''
        for line in io.StringIO(content):
            line = line.rstrip('\r\n')
            if not line:
                # dispatch event
                if not event:
                    event = 'message'
                if data.endswith('\n'):
                    data = data[:-1]
                yield (event, data)

                # reset buffer
                event = ''
                data = ''

            try:
                pos = line.index(':')
            except ValueError:
                field = line
                value = ''
            else:
                field = line[:pos]
                value = line[pos + 1:]
                if value.startswith(' '):
                    value = value[1:]

            if field == 'event':
                event = value
            elif field == 'data':
                data += value + '\n'

    def parse_sse_objects(self, content):
        """Parse SSE response with JSON objects.
        """
        results = []
        for event, data in self.parse_sse(content):
            data = json.loads(data) if data else None
            results.append((event, data))
        return results


class TestView(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check1(self, mock_abort):
        with self.app.test_client() as c, mock.patch('builtins.open', side_effect=PermissionError('Forbidden')):
            c.get('/index.html')
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check2(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass
        with self.app.test_client() as c, mock.patch('zipfile.ZipFile.__init__', side_effect=PermissionError('Forbidden')):
            c.get('/deep/archive.zip!/')
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_directory(self, mock_template):
        with self.app.test_client() as c:
            r = c.get('/subdir')
            self.assertEqual(r.status_code, 302)
            self.assertEqual(r.headers['Location'], 'http://localhost/subdir/')

            r = c.get('/subdir/')
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            self.assertEqual(r.headers['Cache-Control'], 'no-store')
            self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
            self.assertEqual(r.headers['X-Frame-Options'], 'deny')
            mock_template.call_args[1]['subentries'] = set(mock_template.call_args[1]['subentries'])
            mock_template.assert_called_once_with(
                'index.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/subdir/',
                pathparts=['/subdir'],
                subentries={
                    ('file.txt', 'file', 3, os.stat(os.path.join(self.root, 'subdir', 'file.txt')).st_mtime),
                    ('sub', 'dir', None, os.stat(os.path.join(self.root, 'subdir', 'sub')).st_mtime),
                },
            )

    def test_file(self):
        with self.app.test_client() as c:
            r = c.get('/index.html', buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html')
            self.assertEqual(r.headers['Content-Length'], str(os.stat(os.path.join(self.root, 'index.html')).st_size))
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertEqual(r.data.decode('UTF-8').replace('\r\n', '\n'), """<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body>Hello World! 你好</body>
</html>""")

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/index.html', headers={
                'If-None-Match': etag,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/index.html', headers={
                'If-Modified-Since': lm,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 206 for a ranged request
            r = c.get('/index.html', headers={
                'Range': 'bytes=0-14',
            }, buffered=True)
            self.assertEqual(r.status_code, 206)
            self.assertEqual(r.data.decode('UTF-8').replace('\r\n', '\n'), '<!DOCTYPE html>')

    def test_htz(self):
        with zipfile.ZipFile(self.test_htz, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('index.html', DUMMY_ZIP_DT), 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.htz', buffered=True)
            self.assertEqual(r.status_code, 302)
            self.assertEqual(r.headers['Location'], 'http://localhost/deep/archive.htz!/index.html')

    def test_maff(self):
        # 1 page
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('19870101/index.html', DUMMY_ZIP_DT), 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.maff', buffered=True)
            self.assertEqual(r.status_code, 302)
            self.assertEqual(r.headers['Location'], 'http://localhost/deep/archive.maff!/19870101/index.html')

        # 0 page
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            pass

        with self.app.test_client() as c, mock.patch('webscrapbook.app.render_template', return_value='') as mock_template:
            r = c.get('/deep/archive.maff', buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
            self.assertEqual(r.headers['X-Frame-Options'], 'deny')
            mock_template.assert_called_once_with(
                'maff_index.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/archive.maff',
                pages=[],
            )

        # 2+ pages
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('19870101/index.html', DUMMY_ZIP_DT), 'Hello World! 你好')
            zh.writestr(zipfile.ZipInfo('19870201/index.html', DUMMY_ZIP_DT2), 'Hello World! 你好嗎')

        with self.app.test_client() as c, mock.patch('webscrapbook.app.render_template', return_value='') as mock_template:
            r = c.get('/deep/archive.maff', buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
            self.assertEqual(r.headers['X-Frame-Options'], 'deny')
            mock_template.assert_called_once_with(
                'maff_index.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/archive.maff',
                pages=[
                    (None, None, None, '19870101/index.html', None),
                    (None, None, None, '19870201/index.html', None),
                ],
            )

    def test_zip(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('index.html', DUMMY_ZIP_DT), 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip', buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/zip')
            self.assertNotEqual(r.headers['Content-Length'], '19')
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])

    def test_markdown(self):
        with self.app.test_client() as c:
            with mock.patch('webscrapbook.app.render_template', return_value='') as mock_template:
                r = c.get('/index.md')
                self.assertEqual(r.status_code, 200)
                self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
                self.assertNotEqual(r.headers['Content-Length'], str(os.stat(os.path.join(self.root, 'index.md')).st_size))
                self.assertEqual(r.headers['Cache-Control'], 'no-cache')
                self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
                self.assertIsNotNone(r.headers['Last-Modified'])
                self.assertIsNotNone(r.headers['ETag'])
                self.assertIsNone(r.headers.get('Accept-Ranges'))
                mock_template.assert_called_once_with(
                    'markdown.html',
                    sitename='WebScrapBook',
                    is_local=True,
                    base='',
                    path='/index.md',
                    pathparts=['/index.md'],
                    content='<h2>Header</h2>\n<p>Hello 你好</p>\n',
                )

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/index.md', headers={
                'If-None-Match': etag,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/index.md', headers={
                'If-Modified-Since': lm,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

    def test_meta_refresh(self):
        with self.app.test_client() as c:
            r = c.get('/refresh.htm')
            self.assertEqual(r.status_code, 302)
            self.assertEqual(r.headers['Location'], 'http://localhost/index.html')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/nonexist')
            mock_abort.assert_called_once_with(404)

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_zip_subdir(self, mock_template):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('index.html', DUMMY_ZIP_DT), 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/', buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
            self.assertEqual(r.headers['X-Frame-Options'], 'deny')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            with self.assertRaises(KeyError):
                r.headers['Accept-Ranges']
            mock_template.call_args[1]['subentries'] = set(mock_template.call_args[1]['subentries'])
            mock_template.assert_called_once_with(
                'index.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/archive.zip!/',
                pathparts=['/deep/archive.zip', ''],
                subentries={
                    ('index.html', 'file', 19, DUMMY_TS),
                },
            )

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/deep/archive.zip!/', headers={
                'If-None-Match': etag,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/deep/archive.zip!/', headers={
                'If-Modified-Since': lm,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_subdir_noslash(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('subdir/', DUMMY_ZIP_DT), '')
            zh.writestr(zipfile.ZipInfo('subdir/index.html', DUMMY_ZIP_DT2), 'Hello World! 你好')

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/subdir', buffered=True)
            mock_abort.assert_called_once_with(404)

    def test_zip_subfile(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('index.html', DUMMY_ZIP_DT), 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/index.html', buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html')
            self.assertEqual(r.headers['Content-Length'], '19')
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertEqual(r.data.decode('UTF-8'), 'Hello World! 你好')

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/deep/archive.zip!/index.html', headers={
                'If-None-Match': etag,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/deep/archive.zip!/index.html', headers={
                'If-Modified-Since': lm,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 206 for a ranged request
            r = c.get('/deep/archive.zip!/index.html', headers={
                'Range': 'bytes=0-11',
            }, buffered=True)
            self.assertEqual(r.status_code, 206)
            self.assertEqual(r.data.decode('UTF-8').replace('\r\n', '\n'), 'Hello World!')

    def test_zip_subfile_nested(self):
        with zipfile.ZipFile(self.test_htz, 'w') as zh:
            buf1 = io.BytesIO()
            with zipfile.ZipFile(buf1, 'w') as zh1:
                zh1.writestr(zipfile.ZipInfo('index.html', DUMMY_ZIP_DT2), 'Hello World')
            zh.writestr(zipfile.ZipInfo('entry1.htz', DUMMY_ZIP_DT), buf1.getvalue())

        with self.app.test_client() as c:
            r = c.get('/deep/archive.htz!/entry1.htz')
            self.assertEqual(r.status_code, 302)
            self.assertEqual(r.headers['Location'], 'http://localhost/deep/archive.htz!/entry1.htz!/index.html')

            r = c.get('/deep/archive.htz!/entry1.htz!/index.html')
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html')
            self.assertEqual(r.headers['Content-Length'], '11')
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertEqual(r.data.decode('UTF-8'), 'Hello World')

    def test_zip_markdown(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('index.md', DUMMY_ZIP_DT), '## Header\n\nHello 你好')

        with self.app.test_client() as c:
            with mock.patch('webscrapbook.app.render_template', return_value='') as mock_template:
                r = c.get('/deep/archive.zip!/index.md', buffered=True)
                self.assertEqual(r.status_code, 200)
                self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
                self.assertNotEqual(r.headers['Content-Length'], '23')
                self.assertEqual(r.headers['Cache-Control'], 'no-cache')
                self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
                self.assertIsNotNone(r.headers['Last-Modified'])
                self.assertIsNotNone(r.headers['ETag'])
                self.assertIsNone(r.headers.get('Accept-Ranges'))
                mock_template.assert_called_once_with(
                    'markdown.html',
                    sitename='WebScrapBook',
                    is_local=True,
                    base='',
                    path='/deep/archive.zip!/index.md',
                    pathparts=['/deep/archive.zip', 'index.md'],
                    content='<h2>Header</h2>\n<p>Hello 你好</p>\n',
                )

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/deep/archive.zip!/index.md', headers={
                'If-None-Match': etag,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/deep/archive.zip!/index.md', headers={
                'If-Modified-Since': lm,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

    def test_zip_meta_refresh(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('refresh.htm', DUMMY_ZIP_DT), '<meta http-equiv="refresh" content="0;url=index.html">')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/refresh.htm', buffered=True)
            self.assertEqual(r.status_code, 302)
            self.assertEqual(r.headers['Location'], 'http://localhost/deep/archive.zip!/index.html')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_zip_nonexist(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist')
            mock_abort.assert_called_once_with(404)

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist/')
            mock_abort.assert_called_once_with(404)

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist.txt')
            mock_abort.assert_called_once_with(404)

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist.txt/')
            mock_abort.assert_called_once_with(404)

    @mock.patch('webscrapbook.app.action_info', return_value='')
    def test_json(self, mock_info):
        with self.app.test_client() as c:
            c.get('/', query_string={'f': 'json'})
            mock_info.assert_called_once_with()


class TestInfo(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """Require format."""
        with self.app.test_client() as c:
            c.get('/', query_string={'a': 'info'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check(self, mock_abort):
        with self.app.test_client() as c, mock.patch('webscrapbook.app.file_info', side_effect=PermissionError('Forbidden')):
            c.get('/index.html', query_string={'a': 'info', 'f': 'json'})
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check2(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass
        with self.app.test_client() as c, mock.patch('webscrapbook.util.fs.open_archive_path', side_effect=PermissionError('Forbidden')):
            c.get('/deep/archive.zip!/', query_string={'a': 'info', 'f': 'json'})
            mock_abort.assert_called_once_with(403)

    def test_directory(self):
        with self.app.test_client() as c:
            r = c.get('/subdir', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'subdir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': os.stat(os.path.join(self.root, 'subdir')).st_mtime,
                    'mime': None,
                },
            })

            r = c.get('/subdir/', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'subdir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': os.stat(os.path.join(self.root, 'subdir')).st_mtime,
                    'mime': None,
                },
            })

    def test_file(self):
        files = [
            {'filename': 'index.html', 'mime': 'text/html'},
            {'filename': 'index.md', 'mime': 'text/markdown'},
            {'filename': 'archive.htz', 'mime': 'application/html+zip'},
            {'filename': 'archive.maff', 'mime': 'application/x-maff'},
            {'filename': 'archive.zip', 'mime': 'application/zip'},
        ]

        for file in files:
            filename = file['filename']
            mime = file['mime']
            with self.subTest(filename=filename, mime=mime):
                file_path = os.path.join(self.test_dir, filename)
                url_path = '/deep/' + filename
                if os.path.splitext(filename)[1] in ('.zip', '.htz', '.maff'):
                    with zipfile.ZipFile(file_path, 'w'):
                        pass
                else:
                    with open(file_path, 'w'):
                        pass
                stat = os.stat(file_path)

                with self.app.test_client() as c:
                    r = c.get(url_path, query_string={'a': 'info', 'f': 'json'})
                    self.assertEqual(r.status_code, 200)
                    self.assertEqual(r.headers['Content-Type'], 'application/json')
                    self.assertEqual(r.json, {
                        'data': {
                            'name': filename,
                            'type': 'file',
                            'size': stat.st_size,
                            'last_modified': stat.st_mtime,
                            'mime': mime,
                        },
                    })

    def test_file_zip(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('explicit_dir/', DUMMY_ZIP_DT), '')
            zh.writestr(zipfile.ZipInfo('explicit_dir/index.html', DUMMY_ZIP_DT2), 'Hello World! 你好')
            zh.writestr(zipfile.ZipInfo('implicit_dir/index.html', DUMMY_ZIP_DT3), 'Hello World! 你好嗎')

            buf1 = io.BytesIO()
            with zipfile.ZipFile(buf1, 'w') as zh1:
                zh1.writestr(zipfile.ZipInfo('implicit_dir/index.html', DUMMY_ZIP_DT5), 'ABC')
            zh.writestr(zipfile.ZipInfo('entry1.zip', DUMMY_ZIP_DT4), buf1.getvalue())

        with self.app.test_client() as c:
            # directory
            r = c.get('/deep/archive.zip!/explicit_dir', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'explicit_dir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': DUMMY_TS,
                    'mime': None,
                },
            })

            # directory (slash)
            r = c.get('/deep/archive.zip!/explicit_dir/', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'explicit_dir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': DUMMY_TS,
                    'mime': None,
                },
            })

            # directory (implicit, root)
            r = c.get('/deep/archive.zip!/', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': '',
                    'type': 'dir',
                    'size': None,
                    'last_modified': None,
                    'mime': None,
                },
            })

            # directory (implicit)
            r = c.get('/deep/archive.zip!/implicit_dir', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'implicit_dir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': None,
                    'mime': None,
                },
            })

            # directory (implicit, slash)
            r = c.get('/deep/archive.zip!/implicit_dir/', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'implicit_dir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': None,
                    'mime': None,
                },
            })

            # file
            r = c.get('/deep/archive.zip!/explicit_dir/index.html', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'index.html',
                    'type': 'file',
                    'size': 19,
                    'last_modified': DUMMY_TS2,
                    'mime': 'text/html',
                },
            })

            # nested directory (implicit)
            r = c.get('/deep/archive.zip!/entry1.zip!/implicit_dir', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'implicit_dir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': None,
                    'mime': None,
                },
            })

            # nested file
            r = c.get('/deep/archive.zip!/entry1.zip!/implicit_dir/index.html', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'index.html',
                    'type': 'file',
                    'size': 3,
                    'last_modified': DUMMY_TS5,
                    'mime': 'text/html',
                },
            })

    def test_nonexist(self):
        with self.app.test_client() as c:
            r = c.get('/nonexist', query_string={'a': 'info', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'name': 'nonexist',
                    'type': None,
                    'size': None,
                    'last_modified': None,
                    'mime': None,
                },
            })


class TestList(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check1(self, mock_abort):
        with self.app.test_client() as c, mock.patch('os.scandir', side_effect=PermissionError('Forbidden')):
            c.get('/subdir/', query_string={'a': 'list', 'f': 'json'})
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check2(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass
        with self.app.test_client() as c, mock.patch('zipfile.ZipFile.__init__', side_effect=PermissionError('Forbidden')):
            c.get('/deep/archive.zip!/', query_string={'a': 'list', 'f': 'json'})
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """Require format."""
        with self.app.test_client() as c:
            c.get('/', query_string={'a': 'list'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    def test_directory(self):
        with self.app.test_client() as c:
            r = c.get('/subdir', query_string={'a': 'list', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertCountEqual(r.json, {
                'data': [
                    {
                        'name': 'file.txt',
                        'type': 'file',
                        'size': 3,
                        'last_modified': os.stat(os.path.join(self.root, 'subdir', 'file.txt')).st_mtime,
                    },
                    {
                        'name': 'sub',
                        'type': 'dir',
                        'size': None,
                        'last_modified': os.stat(os.path.join(self.root, 'subdir', 'sub')).st_mtime,
                    },
                ],
            })

            r = c.get('/subdir/', query_string={'a': 'list', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertCountEqual(r.json, {
                'data': [
                    {
                        'name': 'file.txt',
                        'type': 'file',
                        'size': 3,
                        'last_modified': os.stat(os.path.join(self.root, 'subdir', 'file.txt')).st_mtime,
                    },
                    {
                        'name': 'sub',
                        'type': 'dir',
                        'size': None,
                        'last_modified': os.stat(os.path.join(self.root, 'subdir', 'sub')).st_mtime,
                    },
                ],
            })

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/index.html', query_string={'a': 'list', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'Directory does not exist.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/nonexist', query_string={'a': 'list', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'Directory does not exist.')

    def test_zip(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('explicit_dir/', DUMMY_ZIP_DT), '')
            zh.writestr(zipfile.ZipInfo('explicit_dir/index.html', DUMMY_ZIP_DT2), 'Hello World! 你好')
            zh.writestr(zipfile.ZipInfo('explicit_dir/subdir/', DUMMY_ZIP_DT3), '')
            zh.writestr(zipfile.ZipInfo('implicit_dir/index.html', DUMMY_ZIP_DT4), 'Hello World! 你好嗎')
            zh.writestr(zipfile.ZipInfo('implicit_dir/subdir/index.html', DUMMY_ZIP_DT5), 'Hello World!')

            buf1 = io.BytesIO()
            with zipfile.ZipFile(buf1, 'w') as zh1:
                zh1.writestr(zipfile.ZipInfo('index.html', DUMMY_ZIP_DT7), 'ABC')
            zh.writestr(zipfile.ZipInfo('entry1.zip', DUMMY_ZIP_DT6), buf1.getvalue())

        with self.app.test_client() as c:
            # explicit dir (no slash)
            r = c.get('/deep/archive.zip!/explicit_dir', query_string={'a': 'list', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(r.json, {
                'data': [
                    {
                        'name': 'index.html',
                        'type': 'file',
                        'size': 19,
                        'last_modified': DUMMY_TS2,
                    },
                    {
                        'name': 'subdir',
                        'type': 'dir',
                        'size': None,
                        'last_modified': DUMMY_TS3,
                    },
                ],
            })

            # explicit dir
            r = c.get('/deep/archive.zip!/explicit_dir/', query_string={'a': 'list', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(r.json, {
                'data': [
                    {
                        'name': 'index.html',
                        'type': 'file',
                        'size': 19,
                        'last_modified': DUMMY_TS2,
                    },
                    {
                        'name': 'subdir',
                        'type': 'dir',
                        'size': None,
                        'last_modified': DUMMY_TS3,
                    },
                ],
            })

            # implicit dir (no slash)
            r = c.get('/deep/archive.zip!/implicit_dir', query_string={'a': 'list', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(r.json, {
                'data': [
                    {
                        'name': 'index.html',
                        'type': 'file',
                        'size': 22,
                        'last_modified': DUMMY_TS4,
                    },
                    {
                        'name': 'subdir',
                        'type': 'dir',
                        'size': None,
                        'last_modified': None,
                    },
                ],
            })

            # implicit dir
            r = c.get('/deep/archive.zip!/implicit_dir/', query_string={'a': 'list', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(r.json, {
                'data': [
                    {
                        'name': 'index.html',
                        'type': 'file',
                        'size': 22,
                        'last_modified': DUMMY_TS4,
                    },
                    {
                        'name': 'subdir',
                        'type': 'dir',
                        'size': None,
                        'last_modified': None,
                    },
                ],
            })

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/deep/archive.zip!/implicit_dir/', query_string={'a': 'list', 'f': 'json'}, headers={
                'If-None-Match': etag,
            })
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/deep/archive.zip!/implicit_dir/', query_string={'a': 'list', 'f': 'json'}, headers={
                'If-Modified-Since': lm,
            })
            self.assertEqual(r.status_code, 304)

            # nested directory
            r = c.get('/deep/archive.zip!/entry1.zip!/', query_string={'a': 'list', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(r.json, {
                'data': [
                    {
                        'name': 'index.html',
                        'type': 'file',
                        'size': 3,
                        'last_modified': DUMMY_TS7,
                    },
                ],
            })

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_nonexist(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist', query_string={'a': 'list', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'Directory does not exist.')

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist/', query_string={'a': 'list', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'Directory does not exist.')

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist.txt', query_string={'a': 'list', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'Directory does not exist.')

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist.txt/', query_string={'a': 'list', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'Directory does not exist.')

    def test_sse_directory(self):
        with self.app.test_client() as c:
            r = c.get('/subdir', query_string={'a': 'list', 'f': 'sse'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/event-stream; charset=utf-8')
            self.assertCountEqual(self.parse_sse_objects(r.data.decode('UTF-8')), [
                ('message', {
                    'name': 'file.txt',
                    'type': 'file',
                    'size': 3,
                    'last_modified': os.stat(os.path.join(self.root, 'subdir', 'file.txt')).st_mtime,
                }),
                ('message', {
                    'name': 'sub',
                    'type': 'dir',
                    'size': None,
                    'last_modified': os.stat(os.path.join(self.root, 'subdir', 'sub')).st_mtime,
                }),
                ('complete', None),
            ])

            r = c.get('/subdir/', query_string={'a': 'list', 'f': 'sse'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/event-stream; charset=utf-8')
            self.assertCountEqual(self.parse_sse_objects(r.data.decode('UTF-8')), [
                ('message', {
                    'name': 'file.txt',
                    'type': 'file',
                    'size': 3,
                    'last_modified': os.stat(os.path.join(self.root, 'subdir', 'file.txt')).st_mtime,
                }),
                ('message', {
                    'name': 'sub',
                    'type': 'dir',
                    'size': None,
                    'last_modified': os.stat(os.path.join(self.root, 'subdir', 'sub')).st_mtime,
                }),
                ('complete', None),
            ])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_sse_file(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/index.html', query_string={'a': 'list', 'f': 'sse'})
            mock_abort.assert_called_once_with(404, 'Directory does not exist.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_sse_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/nonexist', query_string={'a': 'list', 'f': 'sse'})
            mock_abort.assert_called_once_with(404, 'Directory does not exist.')

    def test_sse_zip(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr(zipfile.ZipInfo('explicit_dir/', DUMMY_ZIP_DT), '')
            zh.writestr(zipfile.ZipInfo('explicit_dir/index.html', DUMMY_ZIP_DT2), 'Hello World! 你好')
            zh.writestr(zipfile.ZipInfo('explicit_dir/subdir/', DUMMY_ZIP_DT3), '')
            zh.writestr(zipfile.ZipInfo('implicit_dir/index.html', DUMMY_ZIP_DT4), 'Hello World! 你好嗎')
            zh.writestr(zipfile.ZipInfo('implicit_dir/subdir/index.html', DUMMY_ZIP_DT5), 'Hello World!')

        with self.app.test_client() as c:
            # explicit dir (no slash)
            r = c.get('/deep/archive.zip!/explicit_dir', query_string={'a': 'list', 'f': 'sse'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/event-stream; charset=utf-8')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(self.parse_sse_objects(r.data.decode('UTF-8')), [
                ('message', {
                    'name': 'index.html',
                    'type': 'file',
                    'size': 19,
                    'last_modified': DUMMY_TS2,
                }),
                ('message', {
                    'name': 'subdir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': DUMMY_TS3,
                }),
                ('complete', None),
            ])

            # explicit dir
            r = c.get('/deep/archive.zip!/explicit_dir/', query_string={'a': 'list', 'f': 'sse'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/event-stream; charset=utf-8')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(self.parse_sse_objects(r.data.decode('UTF-8')), [
                ('message', {
                    'name': 'index.html',
                    'type': 'file',
                    'size': 19,
                    'last_modified': DUMMY_TS2,
                }),
                ('message', {
                    'name': 'subdir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': DUMMY_TS3,
                }),
                ('complete', None),
            ])

            # implicit dir (no slash)
            r = c.get('/deep/archive.zip!/implicit_dir', query_string={'a': 'list', 'f': 'sse'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/event-stream; charset=utf-8')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(self.parse_sse_objects(r.data.decode('UTF-8')), [
                ('message', {
                    'name': 'index.html',
                    'type': 'file',
                    'size': 22,
                    'last_modified': DUMMY_TS4,
                }),
                ('message', {
                    'name': 'subdir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': None,
                }),
                ('complete', None),
            ])

            # implicit dir
            r = c.get('/deep/archive.zip!/implicit_dir/', query_string={'a': 'list', 'f': 'sse'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/event-stream; charset=utf-8')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertCountEqual(self.parse_sse_objects(r.data.decode('UTF-8')), [
                ('message', {
                    'name': 'index.html',
                    'type': 'file',
                    'size': 22,
                    'last_modified': DUMMY_TS4,
                }),
                ('message', {
                    'name': 'subdir',
                    'type': 'dir',
                    'size': None,
                    'last_modified': None,
                }),
                ('complete', None),
            ])

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/deep/archive.zip!/implicit_dir/', query_string={'a': 'list', 'f': 'sse'}, headers={
                'If-None-Match': etag,
            })
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/deep/archive.zip!/implicit_dir/', query_string={'a': 'list', 'f': 'sse'}, headers={
                'If-Modified-Since': lm,
            })
            self.assertEqual(r.status_code, 304)


class TestSource(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """No format."""
        with self.app.test_client() as c:
            c.get('/index.html', query_string={'a': 'source', 'f': 'json'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check1(self, mock_abort):
        with self.app.test_client() as c, mock.patch('builtins.open', side_effect=PermissionError('Forbidden')):
            c.get('/index.html', query_string={'a': 'source'})
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check2(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass
        with self.app.test_client() as c, mock.patch('zipfile.ZipFile.__init__', side_effect=PermissionError('Forbidden')):
            c.get('/deep/archive.zip!/', query_string={'a': 'source'})
            mock_abort.assert_called_once_with(403)

    def test_file_normal(self):
        with self.app.test_client() as c:
            r = c.get('/index.html', query_string={'a': 'source'}, buffered=True)
            r.encoding = 'UTF-8'
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=utf-8')
            self.assertEqual(r.headers['Content-Disposition'], 'inline')
            self.assertEqual(r.headers['Content-Length'], str(os.stat(os.path.join(self.root, 'index.html')).st_size))
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertEqual(r.data.decode('UTF-8').replace('\r\n', '\n'), """<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body>Hello World! 你好</body>
</html>""")

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/index.html', query_string={'a': 'source'}, headers={
                'If-None-Match': etag,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/index.html', query_string={'a': 'source'}, headers={
                'If-Modified-Since': lm,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 206 for a ranged request
            r = c.get('/index.html', query_string={'a': 'source'}, headers={
                'Range': 'bytes=0-14',
            }, buffered=True)
            self.assertEqual(r.status_code, 206)
            self.assertEqual(r.data.decode('UTF-8').replace('\r\n', '\n'), '<!DOCTYPE html>')

    def test_file_markdown(self):
        with self.app.test_client() as c:
            r = c.get('/index.md', query_string={'a': 'source'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=utf-8')
            self.assertEqual(r.headers['Content-Disposition'], 'inline')
            self.assertEqual(r.headers['Content-Length'], str(os.stat(os.path.join(self.root, 'index.md')).st_size))
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            self.assertEqual(r.data.decode('UTF-8').replace('\r\n', '\n'), '## Header\n\nHello 你好')

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/index.md', query_string={'a': 'source'}, headers={
                'If-None-Match': etag,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/index.md', query_string={'a': 'source'}, headers={
                'If-Modified-Since': lm,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 206 for a ranged request
            r = c.get('/index.md', query_string={'a': 'source'}, headers={
                'Range': 'bytes=0-8',
            }, buffered=True)
            self.assertEqual(r.status_code, 206)
            self.assertEqual(r.data.decode('UTF-8').replace('\r\n', '\n'), '## Header')

    def test_file_binary(self):
        with zipfile.ZipFile(self.test_htz, 'w') as zh:
            zh.writestr('index.html', 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.htz', query_string={'a': 'source'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=utf-8')
            self.assertEqual(r.headers['Content-Disposition'], 'inline')
            self.assertEqual(r.headers['Content-Length'], str(os.stat(self.test_htz).st_size))
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])

    def test_file_encoding(self):
        with self.app.test_client() as c:
            r = c.get('/index.html', query_string={'a': 'source', 'e': 'big5'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=big5')

            r = c.get('/index.html', query_string={'a': 'source', 'encoding': 'big5'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=big5')

            r = c.get('/index.html', query_string={'a': 'source', 'encoding': 'big5'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=big5')

            r = c.get('/index.html', query_string={'a': 'source', 'encoding': 'big5', 'e': 'gbk'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=big5')

            r = c.get('/index.html', query_string={'a': 'source', 'e': 'gbk', 'encoding': 'big5'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=big5')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/nonexist', query_string={'a': 'source'}, buffered=True)
            mock_abort.assert_called_once_with(404)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_directory(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/subdir', query_string={'a': 'source'})
            mock_abort.assert_called_once_with(404)

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/subdir/', query_string={'a': 'source'})
            mock_abort.assert_called_once_with(404)

    def test_file_zip_subfile(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr('index.html', 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/index.html', query_string={'a': 'source'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/plain; charset=utf-8')
            self.assertEqual(r.headers['Content-Disposition'], 'inline')
            self.assertEqual(r.headers['Content-Length'], '19')
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])

            etag = r.headers['ETag']
            lm = r.headers['Last-Modified']

            # 304 for etag
            r = c.get('/deep/archive.zip!/index.html', query_string={'a': 'source'}, headers={
                'If-None-Match': etag,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 304 for last-modified
            r = c.get('/deep/archive.zip!/index.html', query_string={'a': 'source'}, headers={
                'If-Modified-Since': lm,
            }, buffered=True)
            self.assertEqual(r.status_code, 304)

            # 206 for a ranged request
            r = c.get('/deep/archive.zip!/index.html', query_string={'a': 'source'}, headers={
                'Range': 'bytes=0-11',
            }, buffered=True)
            self.assertEqual(r.status_code, 206)
            self.assertEqual(r.data.decode('UTF-8').replace('\r\n', '\n'), 'Hello World!')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_zip_subdir(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr('explicit_dir/', '')
            zh.writestr('explicit_dir/index.html', 'Hello World! 你好')
            zh.writestr('implicit_dir/index.html', 'Hello World! 你好嗎')

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/explicit_dir', query_string={'a': 'source'}, buffered=True)
            mock_abort.assert_called_once_with(404)

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/explicit_dir/', query_string={'a': 'source'}, buffered=True)
            mock_abort.assert_called_once_with(404)

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/implicit_dir', query_string={'a': 'source'}, buffered=True)
            mock_abort.assert_called_once_with(404)

        mock_abort.reset_mock()

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/implicit_dir/', query_string={'a': 'source'}, buffered=True)
            mock_abort.assert_called_once_with(404)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_zip_nonexist(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist', query_string={'a': 'source'}, buffered=True)
            mock_abort.assert_called_once_with(404)


class TestDownload(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """No format."""
        with self.app.test_client() as c:
            c.get('/index.html', query_string={'a': 'download', 'f': 'json'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check1(self, mock_abort):
        with self.app.test_client() as c, mock.patch('builtins.open', side_effect=PermissionError('Forbidden')):
            c.get('/index.html', query_string={'a': 'download'})
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check2(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass
        with self.app.test_client() as c, mock.patch('zipfile.ZipFile.__init__', side_effect=PermissionError('Forbidden')):
            c.get('/deep/archive.zip!/', query_string={'a': 'download'})
            mock_abort.assert_called_once_with(403)

    def test_file_binary(self):
        zfile = os.path.join(self.test_dir, '中文.htz')
        with zipfile.ZipFile(zfile, 'w') as zh:
            zh.writestr('index.html', 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/中文.htz', query_string={'a': 'download'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/html+zip')
            self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''%E4%B8%AD%E6%96%87.htz; filename="%E4%B8%AD%E6%96%87.htz"''')
            self.assertEqual(r.headers['Content-Length'], str(os.stat(zfile).st_size))
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])

    def test_directory01(self):
        root = os.path.join(self.test_dir, '中文')
        os.makedirs(os.path.join(root, 'subdir'), exist_ok=True)
        with open(os.path.join(root, 'subdir', 'bar.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('文字')
        with open(os.path.join(root, 'foo.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('ABC')

        with self.app.test_client() as c:
            r = c.get('/deep/中文', query_string={'a': 'download'})

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''%E4%B8%AD%E6%96%87.zip; filename="%E4%B8%AD%E6%96%87.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(fh) as zh:
            self.assert_file_equal(
                {'file': os.path.join(root, 'subdir')},
                {'zip': zh, 'filename': 'subdir/'},
            )
            self.assert_file_equal(
                {'file': os.path.join(root, 'subdir', 'bar.txt')},
                {'zip': zh, 'filename': 'subdir/bar.txt'},
            )
            self.assert_file_equal(
                {'file': os.path.join(root, 'foo.txt')},
                {'zip': zh, 'filename': 'foo.txt'},
            )

    def test_directory02(self):
        """Test param i"""
        root = os.path.join(self.test_dir, '中文')
        os.makedirs(os.path.join(root, 'subdir'), exist_ok=True)
        with open(os.path.join(root, 'subdir', 'bar.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('文字')
        with open(os.path.join(root, 'foo.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('ABC')

        # i=['subdir/bar.txt']
        with self.app.test_client() as c:
            r = c.get('/deep/中文', query_string={'a': 'download', 'i': 'subdir/bar.txt'})

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''%E4%B8%AD%E6%96%87.zip; filename="%E4%B8%AD%E6%96%87.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(fh) as zh:
            with self.assertRaises(KeyError):
                zh.getinfo('subdir/')
            self.assert_file_equal(
                {'file': os.path.join(root, 'subdir', 'bar.txt')},
                {'zip': zh, 'filename': 'subdir/bar.txt'},
            )
            with self.assertRaises(KeyError):
                zh.getinfo('foo.txt')

        # i=['foo.txt']
        with self.app.test_client() as c:
            r = c.get('/deep/中文', query_string={'a': 'download', 'i': 'foo.txt'})

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''%E4%B8%AD%E6%96%87.zip; filename="%E4%B8%AD%E6%96%87.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(fh) as zh:
            with self.assertRaises(KeyError):
                zh.getinfo('subdir/')
            with self.assertRaises(KeyError):
                zh.getinfo('subdir/bar.txt')
            self.assert_file_equal(
                {'file': os.path.join(root, 'foo.txt')},
                {'zip': zh, 'filename': 'foo.txt'},
            )

        # i=['subdir/bar.txt', 'foo.txt']
        with self.app.test_client() as c:
            r = c.get('/deep/中文', query_string=[('a', 'download'), ('i', 'subdir/bar.txt'), ('i', 'foo.txt')])

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''%E4%B8%AD%E6%96%87.zip; filename="%E4%B8%AD%E6%96%87.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(fh) as zh:
            with self.assertRaises(KeyError):
                zh.getinfo('subdir/')
            self.assert_file_equal(
                {'file': os.path.join(root, 'subdir', 'bar.txt')},
                {'zip': zh, 'filename': 'subdir/bar.txt'},
            )
            self.assert_file_equal(
                {'file': os.path.join(root, 'foo.txt')},
                {'zip': zh, 'filename': 'foo.txt'},
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/nonexist', query_string={'a': 'download'}, buffered=True)
            mock_abort.assert_called_once_with(404)

    def test_file_zip_subfile(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            buf = io.BytesIO()
            with zipfile.ZipFile(buf, 'w'):
                pass
            zh.writestr('中文.zip', buf.getvalue())

        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/中文.zip', query_string={'a': 'download'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/zip')
            self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''%E4%B8%AD%E6%96%87.zip; filename="%E4%B8%AD%E6%96%87.zip"''')
            self.assertEqual(r.headers['Content-Length'], '22')
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])

    def test_file_zip_subdir01(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr('explicit_dir/', '')
            zh.writestr('explicit_dir/subdir/', '')
            zh.writestr('explicit_dir/subdir/foo.txt', 'ABC')
            zh.writestr('explicit_dir/bar.txt', '中文')
            zh.writestr('implicit_dir/subdir/foo.txt', 'ABC')
            zh.writestr('implicit_dir/bar.txt', '中文')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/explicit_dir', query_string={'a': 'download'}, buffered=True)

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''explicit_dir.zip; filename="explicit_dir.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(self.test_zip) as zh:
            with zipfile.ZipFile(fh) as zh2:
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'explicit_dir/subdir/'},
                    {'zip': zh2, 'filename': 'subdir/'},
                )
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'explicit_dir/subdir/foo.txt'},
                    {'zip': zh2, 'filename': 'subdir/foo.txt'},
                )
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'explicit_dir/bar.txt'},
                    {'zip': zh2, 'filename': 'bar.txt'},
                )

        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/implicit_dir', query_string={'a': 'download'}, buffered=True)

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''implicit_dir.zip; filename="implicit_dir.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(self.test_zip) as zh:
            with zipfile.ZipFile(fh) as zh2:
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'implicit_dir/subdir/foo.txt'},
                    {'zip': zh2, 'filename': 'subdir/foo.txt'},
                )
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'implicit_dir/bar.txt'},
                    {'zip': zh2, 'filename': 'bar.txt'},
                )

    def test_file_zip_subdir02(self):
        """Test param i"""
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr('explicit_dir/', '')
            zh.writestr('explicit_dir/subdir/', '')
            zh.writestr('explicit_dir/subdir/foo.txt', 'ABC')
            zh.writestr('explicit_dir/bar.txt', '中文')
            zh.writestr('implicit_dir/subdir/foo.txt', 'ABC')
            zh.writestr('implicit_dir/bar.txt', '中文')

        # i=['subdir/foo.txt']
        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/explicit_dir', query_string={'a': 'download', 'i': 'subdir/foo.txt'}, buffered=True)

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''explicit_dir.zip; filename="explicit_dir.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(self.test_zip) as zh:
            with zipfile.ZipFile(fh) as zh2:
                with self.assertRaises(KeyError):
                    zh2.getinfo('subdir/')
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'explicit_dir/subdir/foo.txt'},
                    {'zip': zh2, 'filename': 'subdir/foo.txt'},
                )
                with self.assertRaises(KeyError):
                    zh2.getinfo('bar.txt')

        # i=['bar.txt']
        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/explicit_dir', query_string={'a': 'download', 'i': 'bar.txt'}, buffered=True)

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''explicit_dir.zip; filename="explicit_dir.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(self.test_zip) as zh:
            with zipfile.ZipFile(fh) as zh2:
                with self.assertRaises(KeyError):
                    zh2.getinfo('subdir/')
                with self.assertRaises(KeyError):
                    zh2.getinfo('subdir/foo.txt')
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'implicit_dir/bar.txt'},
                    {'zip': zh2, 'filename': 'bar.txt'},
                )

        # i=['subdir/foo.txt', 'bar.txt']
        with self.app.test_client() as c:
            r = c.get('/deep/archive.zip!/explicit_dir', query_string=[('a', 'download'), ('i', 'subdir/foo.txt'), ('i', 'bar.txt')], buffered=True)

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/zip')
        self.assertEqual(r.headers['Content-Disposition'], '''attachment; filename*=UTF-8''explicit_dir.zip; filename="explicit_dir.zip"''')
        self.assertIsNone(r.headers.get('Content-Length'))
        self.assertEqual(r.headers['Cache-Control'], 'no-store')
        self.assertEqual(r.headers['Content-Security-Policy'], "frame-ancestors 'none';")
        fh = io.BytesIO(r.data)
        with zipfile.ZipFile(self.test_zip) as zh:
            with zipfile.ZipFile(fh) as zh2:
                with self.assertRaises(KeyError):
                    zh2.getinfo('subdir/')
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'explicit_dir/subdir/foo.txt'},
                    {'zip': zh2, 'filename': 'subdir/foo.txt'},
                )
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'implicit_dir/bar.txt'},
                    {'zip': zh2, 'filename': 'bar.txt'},
                )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_zip_nonexist(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass

        with self.app.test_client() as c:
            c.get('/deep/archive.zip!/nonexist', query_string={'a': 'download'}, buffered=True)
            mock_abort.assert_called_once_with(404)


class TestStatic(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """No format."""
        with self.app.test_client() as c:
            c.get('/index.css', query_string={'a': 'static', 'f': 'json'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check(self, mock_abort):
        with self.app.test_client() as c, mock.patch('builtins.open', side_effect=PermissionError('Forbidden')):
            c.get('/index.css', query_string={'a': 'static'})
            mock_abort.assert_called_once_with(403)

    def test_file(self):
        with self.app.test_client() as c:
            r = c.get('/index.css', query_string={'a': 'static'}, buffered=True)
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/css; charset=utf-8')
            self.assertEqual(r.headers['Accept-Ranges'], 'bytes')
            self.assertEqual(r.headers['Cache-Control'], 'no-cache')
            self.assertEqual(r.headers['Content-Security-Policy'], "connect-src 'none'; form-action 'none';")
            self.assertIsNotNone(r.headers['Last-Modified'])
            self.assertIsNotNone(r.headers['ETag'])
            with open(os.path.join(STATIC_DIR, 'index.css'), 'rb') as fh:
                self.assertEqual(r.data, fh.read())

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/nonexist', query_string={'a': 'static'})
            mock_abort.assert_called_once_with(404)


class TestConfig(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """Require format."""
        with self.app.test_client() as c:
            c.get('/', query_string={'a': 'config'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    def test_config(self):
        with self.app.test_client() as c:
            r = c.get('/', query_string={'a': 'config', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': {
                    'app': {
                        'name': 'WebScrapBook',
                        'theme': 'default',
                        'locale': '',
                        'base': '',
                        'is_local': True,
                        'backup_dir': '.wsb/backup',
                    },
                    'book': {
                        '': {
                            'name': 'scrapbook',
                            'top_dir': '',
                            'data_dir': '',
                            'tree_dir': WSB_DIR + '/tree',
                            'index': WSB_DIR + '/tree/map.html',
                            'no_tree': False,
                        }
                    },
                    'VERSION': webscrapbook.__version__,
                    'WSB_DIR': WSB_DIR,
                    'WSB_CONFIG': WSB_CONFIG,
                    'WSB_EXTENSION_MIN_VERSION': WSB_EXTENSION_MIN_VERSION,
                },
            })


class TestEdit(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """No format."""
        with open(self.test_html, 'wb') as fh:
            fh.write('你好𧌒蟲'.encode('UTF-8'))

        with self.app.test_client() as c:
            c.get('/index.html', query_string={'a': 'edit', 'f': 'json'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check1(self, mock_abort):
        with self.app.test_client() as c, mock.patch('builtins.open', side_effect=PermissionError('Forbidden')):
            c.get('/deep/temp.html', query_string={'a': 'edit'})
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check2(self, mock_abort):
        with zipfile.ZipFile(self.test_maff, 'w'):
            pass
        with self.app.test_client() as c, mock.patch('zipfile.ZipFile.__init__', side_effect=PermissionError('Forbidden')):
            c.get('/deep/archive.maff!/index.html', query_string={'a': 'edit'})
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_file_utf8(self, mock_template):
        with open(self.test_html, 'wb') as fh:
            fh.write('你好𧌒蟲'.encode('UTF-8'))

        with self.app.test_client() as c:
            r = c.get('/deep/temp.html', query_string={'a': 'edit'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            mock_template.assert_called_once_with(
                'edit.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/temp.html',
                body='你好𧌒蟲',
                encoding=None,
            )

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_file_utf8_encoding(self, mock_template):
        """Use ISO-8859-1 for bad encoding."""
        with open(self.test_html, 'wb') as fh:
            fh.write('你好𧌒蟲'.encode('UTF-8'))

        with self.app.test_client() as c:
            r = c.get('/deep/temp.html', query_string={'a': 'edit', 'e': 'big5'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            mock_template.assert_called_once_with(
                'edit.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/temp.html',
                body='你好𧌒蟲'.encode('UTF-8').decode('ISO-8859-1'),
                encoding='ISO-8859-1',
            )

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_file_big5(self, mock_template):
        """Use ISO-8859-1 for bad encoding."""
        with open(self.test_html, 'wb') as fh:
            fh.write('你好'.encode('Big5'))

        with self.app.test_client() as c:
            r = c.get('/deep/temp.html', query_string={'a': 'edit'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            mock_template.assert_called_once_with(
                'edit.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/temp.html',
                body='你好'.encode('Big5').decode('ISO-8859-1'),
                encoding='ISO-8859-1',
            )

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_file_big5_encoding(self, mock_template):
        with open(self.test_html, 'wb') as fh:
            fh.write('你好'.encode('Big5'))

        with self.app.test_client() as c:
            r = c.get('/deep/temp.html', query_string={'a': 'edit', 'e': 'big5'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            mock_template.assert_called_once_with(
                'edit.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/temp.html',
                body='你好',
                encoding='big5',
            )

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_zip(self, mock_template):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('19870101/index.html', 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.maff!/19870101/index.html', query_string={'a': 'edit'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            mock_template.assert_called_once_with(
                'edit.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/archive.maff!/19870101/index.html',
                body='Hello World! 你好',
                encoding=None,
            )

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_zip_nested(self, mock_template):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            buf1 = io.BytesIO()
            with zipfile.ZipFile(buf1, 'w') as zh1:
                zh1.writestr('index.html', 'Hello World! 你好')
            zh.writestr('19870101/index.htz', buf1.getvalue())

        with self.app.test_client() as c:
            r = c.get('/deep/archive.maff!/19870101/index.htz!/index.html', query_string={'a': 'edit'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            mock_template.assert_called_once_with(
                'edit.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/archive.maff!/19870101/index.htz!/index.html',
                body='Hello World! 你好',
                encoding=None,
            )


class TestEditx(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """No format."""
        with self.app.test_client() as c:
            c.get('/index.html', query_string={'a': 'editx', 'f': 'json'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_permission_check(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass
        with self.app.test_client() as c, mock.patch('zipfile.ZipFile.__init__', side_effect=PermissionError('Forbidden')):
            c.get('/deep/archive.zip!/index.html', query_string={'a': 'editx'})
            mock_abort.assert_called_once_with(403)

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_file(self, mock_template):
        with self.app.test_client() as c:
            r = c.get('/index.html', query_string={'a': 'editx'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            mock_template.assert_called_once_with(
                'editx.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/index.html',
            )

    @mock.patch('webscrapbook.app.render_template', return_value='')
    def test_zip(self, mock_template):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('19870101/index.html', 'Hello World! 你好')

        with self.app.test_client() as c:
            r = c.get('/deep/archive.maff!/19870101/index.html', query_string={'a': 'editx'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')
            mock_template.assert_called_once_with(
                'editx.html',
                sitename='WebScrapBook',
                is_local=True,
                base='',
                path='/deep/archive.maff!/19870101/index.html',
            )


class TestExec(TestActions):
    @mock.patch('webscrapbook.util.fs.launch')
    def test_directory(self, mock_exec):
        with self.app.test_client() as c:
            r = c.get('/subdir', query_string={'a': 'exec', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            mock_exec.assert_called_once_with(os.path.join(self.root, 'subdir'))

    @mock.patch('webscrapbook.util.fs.launch')
    def test_file(self, mock_exec):
        with self.app.test_client() as c:
            r = c.get('/index.html', query_string={'a': 'exec', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            mock_exec.assert_called_once_with(os.path.join(self.root, 'index.html'))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/nonexist.file', query_string={'a': 'exec', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'File does not exist.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip(self, mock_abort):
        with zipfile.ZipFile(self.test_htz, 'w') as zh:
            zh.writestr('index.html', 'Hello World!')

        with self.app.test_client() as c:
            c.get('/deep/archive.htz!/index.html', query_string={'a': 'exec', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'File does not exist.')


class TestBrowse(TestActions):
    @mock.patch('webscrapbook.util.fs.view_in_explorer')
    def test_directory(self, mock_browse):
        with self.app.test_client() as c:
            r = c.get('/subdir', query_string={'a': 'browse', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            mock_browse.assert_called_once_with(os.path.join(self.root, 'subdir'))

    @mock.patch('webscrapbook.util.fs.view_in_explorer')
    def test_file(self, mock_browse):
        with self.app.test_client() as c:
            r = c.get('/index.html', query_string={'a': 'browse', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            mock_browse.assert_called_once_with(os.path.join(self.root, 'index.html'))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/nonexist.file', query_string={'a': 'browse', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'File does not exist.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip(self, mock_abort):
        with zipfile.ZipFile(self.test_htz, 'w') as zh:
            zh.writestr('index.html', 'Hello World!')

        with self.app.test_client() as c:
            c.get('/deep/archive.htz!/index.html', query_string={'a': 'browse', 'f': 'json'})
            mock_abort.assert_called_once_with(404, 'File does not exist.')


class TestToken(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/', query_string={'a': 'token'})
            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    def test_token(self):
        with self.app.test_client() as c:
            r = c.post('/', data={'a': 'token'})
            self.assertEqual(r.status_code, 200)
            token_file = os.path.join(self.root, WSB_DIR, 'server', 'tokens', r.data.decode('UTF-8'))
            self.assertTrue(os.path.isfile(token_file))

    def test_token_json(self):
        with self.app.test_client() as c:
            r = c.post('/', data={'a': 'token', 'f': 'json'})
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            data = r.json
            self.assertEqual(list(data), ['data'])
            self.assertIsInstance(data['data'], str)
            token_file = os.path.join(self.root, WSB_DIR, 'server', 'tokens', data['data'])
            self.assertTrue(os.path.isfile(token_file))


class TestLock(TestActions):
    def setUp(self):
        super().setUp()
        self.lock = os.path.join(self.root, WSB_DIR, 'locks', '098f6bcd4621d373cade4e832627b4f6.lock')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/', query_string={
                'token': token(c),
                'a': 'lock',
                'f': 'json',
                'name': 'test',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/', data={
                'a': 'lock',
                'f': 'json',
                'name': 'test',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_params_check(self, mock_abort):
        """Require name."""
        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'lock',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Lock name is not specified.')

    def test_normal(self):
        with self.app.test_client() as c:
            r = c.post('/', data={
                'token': token(c),
                'a': 'lock',
                'f': 'json',
                'name': 'test',
            })

            with open(self.lock) as fh:
                id = fh.read()

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': id,
            })
            self.assertTrue(os.path.isfile(self.lock))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_lock_existed(self, mock_abort):
        os.makedirs(os.path.dirname(self.lock), exist_ok=True)
        with open(self.lock, 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'lock',
                'f': 'json',
                'name': 'test',
                'chkt': 0,
            })

            mock_abort.assert_called_once_with(503, "Unable to acquire lock 'test'.", retry_after=60)

    def test_stale_lock_existed(self):
        os.makedirs(os.path.dirname(self.lock), exist_ok=True)
        with open(self.lock, 'w') as fh:
            fh.write('oldid')
        t = time.time() - 300
        os.utime(self.lock, (t, t))

        with self.app.test_client() as c:
            r = c.post('/', data={
                'token': token(c),
                'a': 'lock',
                'f': 'json',
                'name': 'test',
            })

            with open(self.lock) as fh:
                id = fh.read()

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': id,
            })

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_directory_existed(self, mock_abort):
        os.makedirs(self.lock, exist_ok=True)

        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'lock',
                'f': 'json',
                'name': 'test',
                'chkt': 0,
            })

            mock_abort.assert_called_once_with(500, "Unable to create lock 'test'.")

    def test_extend(self):
        os.makedirs(os.path.dirname(self.lock), exist_ok=True)
        with open(self.lock, 'w') as fh:
            fh.write('oldid')

        with self.app.test_client() as c:
            r = c.post('/', data={
                'token': token(c),
                'a': 'lock',
                'f': 'json',
                'name': 'test',
                'id': 'oldid',
            })

            with open(self.lock) as fh:
                self.assertEqual(fh.read(), 'oldid')

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {
                'data': 'oldid',
            })

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_extend_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'lock',
                'f': 'json',
                'name': 'test',
                'id': 'oldid',
            })

            mock_abort.assert_called_once_with(400, "Unable to persist lock 'test'.")


class TestUnlock(TestActions):
    def setUp(self):
        super().setUp()
        self.lock = os.path.join(self.root, WSB_DIR, 'locks', '098f6bcd4621d373cade4e832627b4f6.lock')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/', query_string={
                'token': token(c),
                'a': 'unlock',
                'f': 'json',
                'name': 'test',
                'id': 'dummy',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/', data={
                'a': 'unlock',
                'f': 'json',
                'name': 'test',
                'id': 'dummy',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_params_check01(self, mock_abort):
        """Require name."""
        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'unlock',
                'f': 'json',
                'id': 'dummy',
            })

            mock_abort.assert_called_once_with(400, 'Lock name is not specified.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_params_check02(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'unlock',
                'f': 'json',
                'name': 'test',
            })

            mock_abort.assert_called_once_with(400, 'Lock ID is not specified.')

    def test_normal(self):
        os.makedirs(os.path.dirname(self.lock), exist_ok=True)
        with open(self.lock, 'w') as fh:
            fh.write('oldid')

        with self.app.test_client() as c:
            r = c.post('/', data={
                'token': token(c),
                'a': 'unlock',
                'f': 'json',
                'name': 'test',
                'id': 'oldid',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertFalse(os.path.exists(self.lock))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_wrong_id(self, mock_abort):
        os.makedirs(os.path.dirname(self.lock), exist_ok=True)
        with open(self.lock, 'w') as fh:
            fh.write('oldid')

        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'unlock',
                'f': 'json',
                'name': 'test',
                'id': 'dummy',
            })

            mock_abort.assert_called_once_with(400, "Unable to persist lock 'test'.")

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'unlock',
                'f': 'json',
                'name': 'test',
                'id': 'dummy',
            })

            mock_abort.assert_called_once_with(400, "Unable to persist lock 'test'.")

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_directory_existed(self, mock_abort):
        os.makedirs(self.lock, exist_ok=True)

        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'unlock',
                'f': 'json',
                'name': 'test',
                'id': 'dummy',
            })

            mock_abort.assert_called_once_with(400, "Unable to persist lock 'test'.")


class TestMkdir(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/temp', query_string={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/temp', data={
                'a': 'mkdir',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    def test_nonexist(self):
        test_dir = os.path.join(self.test_dir, 'newdir')
        with self.app.test_client() as c:
            r = c.post('/deep/newdir', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isdir(test_dir))

    def test_nonexist_deep(self):
        test_dir = os.path.join(self.test_dir, 'deeper', 'newdir')
        with self.app.test_client() as c:
            r = c.post('/deep/deeper/newdir', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isdir(test_dir))

    def test_dir(self):
        test_dir = os.path.join(self.test_dir, 'newdir')
        os.makedirs(test_dir)
        with self.app.test_client() as c:
            r = c.post('/deep/newdir', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isdir(test_dir))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file(self, mock_abort):
        with open(self.test_html, 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Found something here.')

    def test_zip_nonexist(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/temp', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), ['temp/'])

    def test_zip_nonexist_deep(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/temp/subdir', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), ['temp/subdir/'])

    def test_zip_dir(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('temp/subdir/', '')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/temp/subdir', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), ['temp/subdir/'])

    def test_zip_dir_deep(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            buf1 = io.BytesIO()
            with zipfile.ZipFile(buf1, 'w') as zh1:
                pass
            zh.writestr('20200101/entry.zip', buf1.getvalue())

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/20200101/entry.zip!/20200102', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                with zh.open('20200101/entry.zip') as fh:
                    with zipfile.ZipFile(fh, 'r') as zh1:
                        self.assertEqual(zh1.namelist(), ['20200102/'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_file(self, mock_abort):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('temp/subdir', '123')

        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/temp/subdir', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Found something here.')

    def test_zip_root(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/', data={
                'token': token(c),
                'a': 'mkdir',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), [])


class TestMkzip(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/deep/archive.zip', query_string={
                'token': token(c),
                'a': 'mkzip',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/deep/archive.zip', data={
                'a': 'mkzip',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    def test_nonexist(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.zip', data={
                'token': token(c),
                'a': 'mkzip',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_zip))
            self.assertTrue(zipfile.is_zipfile(self.test_zip))

    def test_file(self):
        with open(self.test_zip, 'w', encoding='UTF-8') as fh:
            fh.write('test')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.zip', data={
                'token': token(c),
                'a': 'mkzip',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_zip))
            self.assertTrue(zipfile.is_zipfile(self.test_zip))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_dir(self, mock_abort):
        os.makedirs(self.test_zip, exist_ok=True)
        with self.app.test_client() as c:
            c.post('/deep/archive.zip', data={
                'token': token(c),
                'a': 'mkzip',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')

    def test_zip_nonexist(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/archive.zip!/entry.zip', data={
                'token': token(c),
                'a': 'mkzip',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            with zipfile.ZipFile(self.test_zip, 'r') as zh:
                with zh.open('entry.zip') as fh:
                    self.assertTrue(zipfile.is_zipfile(fh))

    def test_zip_file(self):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr('entry.zip', 'dummy')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.zip!/entry.zip', data={
                'token': token(c),
                'a': 'mkzip',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            with zipfile.ZipFile(self.test_zip, 'r') as zh:
                with zh.open('entry.zip') as fh:
                    self.assertTrue(zipfile.is_zipfile(fh))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_dir(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w') as zh:
            zh.writestr('entry.zip/', '')

        with self.app.test_client() as c:
            c.post('/deep/archive.zip!/entry.zip', data={
                'token': token(c),
                'a': 'mkzip',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_root(self, mock_abort):
        with zipfile.ZipFile(self.test_zip, 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/archive.zip!/', data={
                'token': token(c),
                'a': 'mkzip',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')


class TestSave(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/deep/temp.html', query_string={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/deep/temp.html', data={
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    def test_save_nonexist(self):
        with self.app.test_client() as c:
            r = c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_html))
            with open(self.test_html, 'r', encoding='UTF-8') as fh:
                self.assertEqual(fh.read(), 'ABC 你好')

    def test_save_nonexist_deep(self):
        with self.app.test_client() as c:
            r = c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_html))
            with open(self.test_html, 'r', encoding='UTF-8') as fh:
                self.assertEqual(fh.read(), 'ABC 你好')

    def test_save_file_existed(self):
        with open(self.test_html, 'w', encoding='UTF-8') as fh:
            fh.write('test')

        with self.app.test_client() as c:
            r = c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_html))
            with open(self.test_html, 'r', encoding='UTF-8') as fh:
                self.assertEqual(fh.read(), 'ABC 你好')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_save_dir(self, mock_abort):
        os.makedirs(self.test_html, exist_ok=True)

        with self.app.test_client() as c:
            c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')

    def test_save_zip_nonexist(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.read('index.html').decode('UTF-8'), 'ABC 你好')

    def test_save_zip_nonexist_deep(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.read('subdir/index.html').decode('UTF-8'), 'ABC 你好')

    def test_save_zip_file(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('subdir/index.html', 'dummy')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.read('subdir/index.html').decode('UTF-8'), 'ABC 你好')

    def test_save_zip_file_nested(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            buf1 = io.BytesIO()
            with zipfile.ZipFile(buf1, 'w') as zh1:
                pass
            zh.writestr('20200101/entry.zip', buf1.getvalue())

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/20200101/entry.zip!/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC 你好'.encode('UTF-8').decode('ISO-8859-1'),
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                with zh.open('20200101/entry.zip') as fh:
                    with zipfile.ZipFile(fh, 'r') as zh1:
                        self.assertEqual(zh1.read('index.html').decode('UTF-8'), 'ABC 你好')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_save_zip_dir(self, mock_abort):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('subdir/index.html/', '')

        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC',
            })

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_save_zip_root(self, mock_abort):
        with zipfile.ZipFile(self.test_maff, 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'text': 'ABC',
            })

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')

    def test_upload_nonexist(self):
        os.makedirs(self.test_dir, exist_ok=True)

        with self.app.test_client() as c:
            r = c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            }, content_type='multipart/form-data')

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_html))
            with open(self.test_html, 'r', encoding='UTF-8') as fh:
                self.assertEqual(fh.read(), 'ABC 你好')

    def test_upload_nonexist_deep(self):
        with self.app.test_client() as c:
            r = c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            }, content_type='multipart/form-data')

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_html))
            with open(self.test_html, 'r', encoding='UTF-8') as fh:
                self.assertEqual(fh.read(), 'ABC 你好')

    def test_upload_file(self):
        os.makedirs(self.test_dir, exist_ok=True)
        with open(self.test_html, 'w', encoding='UTF-8') as fh:
            fh.write('test')

        with self.app.test_client() as c:
            r = c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            }, content_type='multipart/form-data')

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_html))
            with open(self.test_html, 'r', encoding='UTF-8') as fh:
                self.assertEqual(fh.read(), 'ABC 你好')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_upload_dir(self, mock_abort):
        os.makedirs(self.test_html, exist_ok=True)

        with self.app.test_client() as c:
            c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            }, content_type='multipart/form-data')

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')

    def test_upload_zip_nonexist(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            }, content_type='multipart/form-data')

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.read('index.html').decode('UTF-8'), 'ABC 你好')

    def test_upload_zip_nonexist_deep(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            }, content_type='multipart/form-data')

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.read('subdir/index.html').decode('UTF-8'), 'ABC 你好')

    def test_upload_zip_file(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('subdir/index.html', 'dummy')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            }, content_type='multipart/form-data')

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.read('subdir/index.html').decode('UTF-8'), 'ABC 你好')

    def test_upload_zip_file_nested(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            buf1 = io.BytesIO()
            with zipfile.ZipFile(buf1, 'w') as zh1:
                pass
            zh.writestr('20200101/entry.zip', buf1.getvalue())

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/20200101/entry.zip!/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                with zh.open('20200101/entry.zip') as fh:
                    with zipfile.ZipFile(fh, 'r') as zh1:
                        self.assertEqual(zh1.read('index.html').decode('UTF-8'), 'ABC 你好')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_upload_zip_dir(self, mock_abort):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('subdir/index.html/', '')

        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            })

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_upload_zip_root(self, mock_abort):
        with zipfile.ZipFile(self.test_maff, 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/', data={
                'token': token(c),
                'a': 'save',
                'f': 'json',
                'upload': (io.BytesIO('ABC 你好'.encode('UTF-8')), 'test.txt'),
            })

            mock_abort.assert_called_once_with(400, 'Found a non-file here.')


class TestDelete(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with open(self.test_html, 'w', encoding='UTF-8'):
            pass

        with self.app.test_client() as c:
            c.get('/deep/temp.html', query_string={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with open(self.test_html, 'w', encoding='UTF-8'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/temp.html', data={
                'a': 'delete',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    def test_file(self):
        with open(self.test_html, 'w', encoding='UTF-8'):
            pass

        with self.app.test_client() as c:
            r = c.post('/deep/temp.html', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertFalse(os.path.exists(self.test_html))

    def test_directory(self):
        test_dir = os.path.join(self.test_dir, 'newdir')
        os.makedirs(test_dir)

        with self.app.test_client() as c:
            r = c.post('/deep/newdir', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertFalse(os.path.exists(test_dir))

    def test_directory_with_content(self):
        with open(self.test_html, 'w', encoding='UTF-8'):
            pass

        with self.app.test_client() as c:
            r = c.post('/deep', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertFalse(os.path.isfile(self.test_dir))

    @require_junction()
    def test_junction1(self):
        """Delete the link entity rather than the referenced directory."""
        ref = os.path.join(self.test_dir, 'subdir')
        ref2 = os.path.join(self.test_dir, 'subdir', 'test.txt')
        dst = os.path.join(self.test_dir, 'junction')

        os.makedirs(ref)
        with open(ref2, 'w', encoding='UTF-8') as fh:
            fh.write('dummy')
        junction(ref, dst)

        with self.app.test_client() as c:
            r = c.post('/deep/junction', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(dst))
            self.assertTrue(os.path.isdir(ref))
            self.assertTrue(os.path.isfile(ref2))

    @require_junction()
    def test_junction2(self):
        """Delete the link entity even if target not exist."""
        ref = os.path.join(self.test_dir, 'nonexist')
        dst = os.path.join(self.test_dir, 'junction')

        junction(ref, dst)

        with self.app.test_client() as c:
            r = c.post('/deep/junction', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(dst))

    @require_junction()
    @require_junction_deletion()
    def test_junction_deep(self):
        """Delete junction entities without altering the referenced directory.
        """
        ref = os.path.join(self.test_dir, 'subdir')
        ref2 = os.path.join(self.test_dir, 'subdir', 'test.txt')
        ref3 = os.path.join(self.test_dir, 'subdir2', 'junction')
        dst = os.path.join(self.test_dir, 'subdir2')

        os.makedirs(ref)
        with open(ref2, 'w', encoding='UTF-8') as fh:
            fh.write('dummy')
        os.makedirs(dst)
        junction(ref, ref3)

        with self.app.test_client() as c:
            r = c.post('/deep/subdir2', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(dst))
            self.assertTrue(os.path.isdir(ref))
            self.assertTrue(os.path.isfile(ref2))

    @require_symlink()
    def test_symlink1(self):
        """Delete the link entity rather than the referenced directory."""
        ref = os.path.join(self.test_dir, 'subdir')
        ref2 = os.path.join(self.test_dir, 'subdir', 'test.txt')
        dst = os.path.join(self.test_dir, 'symlink')

        os.makedirs(ref)
        with open(ref2, 'w', encoding='UTF-8') as fh:
            fh.write('dummy')
        os.symlink(ref, dst)

        with self.app.test_client() as c:
            r = c.post('/deep/symlink', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(dst))
            self.assertTrue(os.path.isdir(ref))
            self.assertTrue(os.path.isfile(ref2))

    @require_symlink()
    def test_symlink2(self):
        """Delete the link entity rather than the referenced file."""
        ref = os.path.join(self.test_dir, 'test.txt')
        dst = os.path.join(self.test_dir, 'symlink')

        with open(ref, 'w', encoding='UTF-8') as fh:
            fh.write('dummy')
        os.symlink(ref, dst)

        with self.app.test_client() as c:
            r = c.post('/deep/symlink', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(dst))
            self.assertTrue(os.path.isfile(ref))

    @require_symlink()
    def test_symlink3(self):
        """Delete the link entity even if target not exist."""
        ref = os.path.join(self.test_dir, 'nonexist')
        dst = os.path.join(self.test_dir, 'symlink')

        os.symlink(ref, dst)

        with self.app.test_client() as c:
            r = c.post('/deep/symlink', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(dst))

    @require_symlink()
    def test_symlink_deep(self):
        """Delete symlink entities without altering the referenced directory.
        """
        ref = os.path.join(self.test_dir, 'subdir')
        ref2 = os.path.join(self.test_dir, 'subdir', 'test.txt')
        ref3 = os.path.join(self.test_dir, 'subdir2', 'symlink')
        dst = os.path.join(self.test_dir, 'subdir2')

        os.makedirs(ref)
        with open(ref2, 'w', encoding='UTF-8') as fh:
            fh.write('dummy')
        os.makedirs(dst, exist_ok=True)
        os.symlink(ref, ref3)

        with self.app.test_client() as c:
            r = c.post('/deep/subdir2', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(dst))
            self.assertTrue(os.path.isdir(ref))
            self.assertTrue(os.path.isfile(ref2))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/nonexist', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(404, 'Entry does not exist.')

    def test_zip_file(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('file.txt', 'dummy')
            zh.writestr('subdir/index.html', '')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), ['file.txt'])

    def test_zip_directory(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('file.txt', 'dummy')
            zh.writestr('subdir/', '')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), ['file.txt'])

    def test_zip_directory_with_content(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('file.txt', 'dummy')
            zh.writestr('subdir/', '')
            zh.writestr('subdir/dir/', '')
            zh.writestr('subdir/index.html', '')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), ['file.txt'])

    def test_zip_implicit_directory_with_content(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('file.txt', 'dummy')
            zh.writestr('subdir/dir/', '')
            zh.writestr('subdir/index.html', '')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), ['file.txt'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_nonexist(self, mock_abort):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('file.txt', 'dummy')

        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/nonexist', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(404, 'Entry does not exist.')

    def test_zip_directory_nested(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            buf1 = io.BytesIO()
            with zipfile.ZipFile(buf1, 'w') as zh1:
                zh1.writestr('subdir/', '')
                zh1.writestr('subdir/index.html', 'ABC 你好')
            zh.writestr('20200101/entry.zip', buf1.getvalue())

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/20200101/entry.zip!/subdir', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                with zh.open('20200101/entry.zip') as fh:
                    with zipfile.ZipFile(fh, 'r') as zh1:
                        self.assertEqual(zh1.namelist(), [])

    def test_zip_root(self):
        with zipfile.ZipFile(self.test_maff, 'w') as zh:
            zh.writestr('file.txt', 'dummy')
            zh.writestr('subdir/dir/', '')
            zh.writestr('subdir/index.html', 'dummy')
            zh.writestr('subdir2/test.txt', 'dummy')

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/', data={
                'token': token(c),
                'a': 'delete',
                'f': 'json',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})
            self.assertTrue(os.path.isfile(self.test_maff))
            with zipfile.ZipFile(self.test_maff, 'r') as zh:
                self.assertEqual(zh.namelist(), [])


class TestMove(TestActions):
    def setUp(self):
        super().setUp()
        os.makedirs(os.path.join(self.test_dir, 'subdir'))
        with open(os.path.join(self.test_dir, 'subdir', 'test.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('ABC 你好')

        with zipfile.ZipFile(self.test_maff, 'w') as fh:
            buf = io.BytesIO()
            with zipfile.ZipFile(buf, 'w') as z:
                z.writestr(
                    zipfile.ZipInfo('subdir/', DUMMY_ZIP_DT4),
                    ''
                )
                z.writestr(
                    zipfile.ZipInfo('subdir/index.html', DUMMY_ZIP_DT5),
                    'Nested maff 測試',
                    compress_type=zipfile.ZIP_DEFLATED,
                )
                z.writestr(
                    zipfile.ZipInfo('subdir2/index.html', DUMMY_ZIP_DT6),
                    'Nested maff 測試',
                    compress_type=zipfile.ZIP_DEFLATED,
                )
                z.writestr(
                    zipfile.ZipInfo('subdir3/index.html/', DUMMY_ZIP_DT7),
                    '',
                )
                z.writestr(
                    zipfile.ZipInfo('subdir4/subdir', DUMMY_ZIP_DT8),
                    'Nested maff 測試',
                    compress_type=zipfile.ZIP_DEFLATED,
                )
            fh.writestr('entry.maff', buf.getvalue())
            fh.writestr(
                zipfile.ZipInfo('subdir/', DUMMY_ZIP_DT),
                ''
            )
            info = zipfile.ZipInfo('subdir/index.html', DUMMY_ZIP_DT2)
            info.comment = 'dummy comment'.encode('UTF-8')
            fh.writestr(
                info,
                'Maff content 測試',
                compress_type=zipfile.ZIP_DEFLATED,
            )
            fh.writestr(
                zipfile.ZipInfo('subdir2/index.html', DUMMY_ZIP_DT3),
                'Maff content 測試',
                compress_type=zipfile.ZIP_DEFLATED,
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/deep/subdir/test.txt', query_string={
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_params_check(self, mock_abort):
        """Require target."""
        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Target is not specified.')

    def test_file(self):
        orig_data = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir', 'test.txt')})

        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'subdir', 'test.txt')))
            self.assert_file_equal(
                orig_data,
                {'file': os.path.join(self.test_dir, 'subdir2', 'test2.txt')},
            )

    def test_directory(self):
        orig_data = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir')})
        orig_data2 = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir', 'test.txt')})

        with self.app.test_client() as c:
            r = c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2/subsubdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'subdir')))
            self.assert_file_equal(
                orig_data,
                {'file': os.path.join(self.test_dir, 'subdir2', 'subsubdir')},
            )
            self.assert_file_equal(
                orig_data2,
                {'file': os.path.join(self.test_dir, 'subdir2', 'subsubdir', 'test.txt')},
            )

    def test_directory_slash(self):
        orig_data = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir')})
        orig_data2 = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir', 'test.txt')})

        with self.app.test_client() as c:
            r = c.post('/deep/subdir/', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2/subsubdir/',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'subdir')))
            self.assert_file_equal(
                orig_data,
                {'file': os.path.join(self.test_dir, 'subdir2', 'subsubdir')},
            )
            self.assert_file_equal(
                orig_data2,
                {'file': os.path.join(self.test_dir, 'subdir2', 'subsubdir', 'test.txt')},
            )

    @require_junction()
    def test_junction(self):
        """Moving the entity rather than the referenced directory."""
        junction(
            os.path.join(self.test_dir, 'nonexist'),
            os.path.join(self.test_dir, 'junction'),
        )

        orig_data = self.get_file_data({'file': os.path.join(self.test_dir, 'junction')})

        with self.app.test_client() as c:
            r = c.post('/deep/junction', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/newdir/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'junction')))
            self.assert_file_equal(
                orig_data,
                {'file': os.path.join(self.test_dir, 'newdir', 'subdir')},
            )

    @require_symlink()
    def test_symlink(self):
        """Moving the entity rather than the referenced directory/file."""
        os.symlink(
            os.path.join(self.test_dir, 'nonexist'),
            os.path.join(self.test_dir, 'symlink')
        )

        orig_data = self.get_file_data({'file': os.path.join(self.test_dir, 'symlink')})

        with self.app.test_client() as c:
            r = c.post('/deep/symlink', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/newdir/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'symlink')))
            self.assert_file_equal(
                orig_data,
                {'file': os.path.join(self.test_dir, 'newdir', 'subdir')},
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/nonexist', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(404, 'Source does not exist.')

    def test_beyond_root(self):
        """Target must be restricted within the root directory."""
        orig_data = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir', 'test.txt')})

        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '../deep/../../../deep/subdir2/test2.txt',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'subdir', 'test.txt')))
            self.assert_file_equal(
                orig_data,
                {'file': os.path.join(self.test_dir, 'subdir2', 'test2.txt')},
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_to_file(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir2', 'test2.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('你好 XYZ')

        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_dir_to_file(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir2', 'test2.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('你好 XYZ')

        with self.app.test_client() as c:
            c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_file_to_dir(self):
        orig_data = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir', 'test.txt')})

        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)

        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'subdir', 'test.txt')))
            self.assert_file_equal(
                orig_data,
                {'file': os.path.join(self.test_dir, 'subdir2', 'test.txt')},
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_to_dir_with_same_file(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir2', 'test.txt'), 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_to_dir_with_same_dir(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2', 'test.txt'), exist_ok=True)

        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_dir_to_dir(self):
        orig_data = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir')})
        orig_data2 = self.get_file_data({'file': os.path.join(self.test_dir, 'subdir', 'test.txt')})

        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)

        with self.app.test_client() as c:
            r = c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'subdir')))
            self.assert_file_equal(
                orig_data,
                {'file': os.path.join(self.test_dir, 'subdir2', 'subdir')},
            )
            self.assert_file_equal(
                orig_data2,
                {'file': os.path.join(self.test_dir, 'subdir2', 'subdir', 'test.txt')},
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_dir_to_dir_with_same_file(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir2', 'subdir'), 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_dir_to_dir_with_same_dir(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2', 'subdir'), exist_ok=True)

        with self.app.test_client() as c:
            c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_dir_to_child(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2', 'subdir'), exist_ok=True)

        with self.app.test_client() as c:
            c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/subdir/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Unable to move into self.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_disk_to_zip(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/deep/test2.txt',
            })

            mock_abort.assert_called_once_with(400, 'Unable to move across a zip.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_disk(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/deep/index2.html',
            })

            mock_abort.assert_called_once_with(400, 'Unable to move across a zip.')

    def test_zip_to_zip_file(self):
        with zipfile.ZipFile(self.test_maff) as zh1:
            orig_data = self.get_file_data({'zip': zh1, 'filename': 'subdir/index.html'})

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/deep/newdir/index2.html',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with self.assertRaises(KeyError):
                    zh1.getinfo('subdir/index.html')

                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            orig_data,
                            {'zip': zh2, 'filename': 'deep/newdir/index2.html'},
                        )

    def test_zip_to_zip_dir(self):
        with zipfile.ZipFile(self.test_maff) as zh1:
            orig_data = self.get_file_data({'zip': zh1, 'filename': 'subdir/'})
            orig_data2 = self.get_file_data({'zip': zh1, 'filename': 'subdir/index.html'})

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/deep/newdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with self.assertRaises(KeyError):
                    zh1.getinfo('subdir/')
                with self.assertRaises(KeyError):
                    zh1.getinfo('subdir/index.html')

                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            orig_data,
                            {'zip': zh2, 'filename': 'deep/newdir/'},
                        )
                        self.assert_file_equal(
                            orig_data2,
                            {'zip': zh2, 'filename': 'deep/newdir/index.html'},
                        )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/nonexist', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/deep/newdir',
            })

            mock_abort.assert_called_once_with(404, 'Source does not exist.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_file_to_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir/index.html',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_dir_to_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir/index.html',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_zip_to_zip_file_to_dir(self):
        with zipfile.ZipFile(self.test_maff) as zh1:
            orig_data = self.get_file_data({'zip': zh1, 'filename': 'subdir/index.html'})

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir4',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with self.assertRaises(KeyError):
                    zh1.getinfo('subdir/index.html')

                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            orig_data,
                            {'zip': zh2, 'filename': 'subdir4/index.html'},
                        )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_file_to_dir_with_same_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_file_to_dir_with_same_dir(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir3',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_zip_to_zip_dir_to_dir1(self):
        with zipfile.ZipFile(self.test_maff) as zh1:
            orig_data = self.get_file_data({'zip': zh1, 'filename': 'subdir/'})
            orig_data2 = self.get_file_data({'zip': zh1, 'filename': 'subdir/index.html'})

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with self.assertRaises(KeyError):
                    zh1.getinfo('subdir/')
                with self.assertRaises(KeyError):
                    zh1.getinfo('subdir/index.html')

                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            orig_data,
                            {'zip': zh2, 'filename': 'subdir/subdir/'},
                        )
                        self.assert_file_equal(
                            orig_data2,
                            {'zip': zh2, 'filename': 'subdir/subdir/index.html'},
                        )

    def test_zip_to_zip_dir_to_dir2(self):
        with zipfile.ZipFile(self.test_maff) as zh1:
            orig_data = self.get_file_data({'zip': zh1, 'filename': 'subdir/'})
            orig_data2 = self.get_file_data({'zip': zh1, 'filename': 'subdir/index.html'})

        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir2',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with self.assertRaises(KeyError):
                    zh1.getinfo('subdir/')
                with self.assertRaises(KeyError):
                    zh1.getinfo('subdir/index.html')

                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            orig_data,
                            {'zip': zh2, 'filename': 'subdir2/subdir/'},
                        )
                        self.assert_file_equal(
                            orig_data2,
                            {'zip': zh2, 'filename': 'subdir2/subdir/index.html'},
                        )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_dir_to_dir_with_same_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir4',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_dir_to_dir_with_same_dir(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'move',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')


class TestCopy(TestActions):
    def setUp(self):
        super().setUp()
        os.makedirs(os.path.join(self.test_dir, 'subdir'))
        with open(os.path.join(self.test_dir, 'subdir', 'test.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('ABC 你好')

        with zipfile.ZipFile(self.test_maff, 'w') as fh:
            buf = io.BytesIO()
            with zipfile.ZipFile(buf, 'w') as z:
                z.writestr(
                    zipfile.ZipInfo('subdir/', DUMMY_ZIP_DT4),
                    ''
                )
                z.writestr(
                    zipfile.ZipInfo('subdir/index.html', DUMMY_ZIP_DT5),
                    'Nested maff 測試',
                    compress_type=zipfile.ZIP_DEFLATED,
                )
                z.writestr(
                    zipfile.ZipInfo('subdir2/index.html', DUMMY_ZIP_DT6),
                    'Nested maff 測試',
                    compress_type=zipfile.ZIP_DEFLATED,
                )
                z.writestr(
                    zipfile.ZipInfo('subdir3/index.html/', DUMMY_ZIP_DT7),
                    '',
                )
                z.writestr(
                    zipfile.ZipInfo('subdir4/subdir', DUMMY_ZIP_DT8),
                    'Nested maff 測試',
                    compress_type=zipfile.ZIP_DEFLATED,
                )
            fh.writestr('entry.maff', buf.getvalue())
            fh.writestr(
                zipfile.ZipInfo('subdir/', DUMMY_ZIP_DT),
                ''
            )
            info = zipfile.ZipInfo('subdir/index.html', DUMMY_ZIP_DT2)
            info.comment = 'dummy comment'.encode('UTF-8')
            fh.writestr(
                info,
                'Maff content 測試',
                compress_type=zipfile.ZIP_DEFLATED,
            )
            fh.writestr(
                zipfile.ZipInfo('subdir2/index.html', DUMMY_ZIP_DT3),
                'Maff content 測試',
                compress_type=zipfile.ZIP_DEFLATED,
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/deep/subdir/test.txt', query_string={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_params_check(self, mock_abort):
        """Require target."""
        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Target is not specified.')

    def test_file(self):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'subdir2', 'test2.txt')},
            )

    def test_directory(self):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2/subsubdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir')},
                {'file': os.path.join(self.test_dir, 'subdir2', 'subsubdir')},
            )
            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'subdir2', 'subsubdir', 'test.txt')},
            )

    def test_directory_slash(self):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir/', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2/subsubdir/',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir')},
                {'file': os.path.join(self.test_dir, 'subdir2', 'subsubdir')},
            )
            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'subdir2', 'subsubdir', 'test.txt')},
            )

    @require_junction()
    def test_junction1(self):
        """Copy junction as a new regular directory."""
        junction(
            os.path.join(self.test_dir, 'subdir'),
            os.path.join(self.test_dir, 'junction'),
        )

        with self.app.test_client() as c:
            r = c.post('/deep/junction', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/deep/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir')},
                {'file': os.path.join(self.test_dir, 'deep', 'subdir')},
            )
            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'deep', 'subdir', 'test.txt')},
            )

    @require_junction()
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_junction2(self, mock_abort):
        """Raises when copying a broken directory junction."""
        junction(
            os.path.join(self.test_dir, 'nonexist'),
            os.path.join(self.test_dir, 'junction'),
        )

        with self.app.test_client() as c:
            c.post('/deep/junction', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/deep/subdir',
            })

            mock_abort.assert_called_once_with(404, 'Source does not exist.')

    @require_junction()
    @mock.patch('sys.stderr', io.StringIO())
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_junction_deep(self, mock_abort):
        """Copy junction entities with referenced directory content.

        - Broken junctions are not copied.
        """
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)

        os.utime(os.path.join(self.test_dir, 'subdir'), (0, DUMMY_TS))

        junction(
            os.path.join(self.test_dir, 'subdir'),
            os.path.join(self.test_dir, 'subdir2', 'junction'),
        )
        junction(
            os.path.join(self.test_dir, 'nonexist'),
            os.path.join(self.test_dir, 'subdir2', 'junction2'),
        )

        with self.app.test_client() as c:
            c.post('/deep/subdir2', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/clone',
            })

            mock_abort.assert_called_once_with(500, 'Fail to copy some files.')
            self.assertEqual(
                glob_files(os.path.join(self.test_dir, 'clone')),
                {
                    os.path.join(self.test_dir, 'clone', ''),
                    os.path.join(self.test_dir, 'clone', 'junction'),
                    os.path.join(self.test_dir, 'clone', 'junction', 'test.txt'),
                },
            )

            # stat of the copy is the link target in Python 3.7 and the link
            # itself in Python 3.8~3.11
            # self.assert_file_equal(
            #     {'file': os.path.join(self.test_dir, 'subdir')},
            #     {'file': os.path.join(self.test_dir, 'clone', 'junction')},
            # )

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'clone', 'junction', 'test.txt')},
            )

    @require_symlink()
    def test_symlink1(self):
        """Copy symlink as a new regular directory."""
        os.symlink(
            os.path.join(self.test_dir, 'subdir'),
            os.path.join(self.test_dir, 'symlink')
        )

        with self.app.test_client() as c:
            r = c.post('/deep/symlink', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/deep/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir')},
                {'file': os.path.join(self.test_dir, 'deep', 'subdir')},
            )
            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'deep', 'subdir', 'test.txt')},
            )

    @require_symlink()
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_symlink2(self, mock_abort):
        """Raises when copying a broken symlink."""
        os.symlink(
            os.path.join(self.test_dir, 'nonexist'),
            os.path.join(self.test_dir, 'symlink')
        )

        with self.app.test_client() as c:
            c.post('/deep/symlink', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/deep/subdir',
            })

            mock_abort.assert_called_once_with(404, 'Source does not exist.')

    @require_symlink()
    @mock.patch('sys.stderr', io.StringIO())
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_symlink_deep(self, mock_abort):
        """Copy symlink entities with referenced directory content.

        - Use stat of the symlink target.
        - Broken symlinks are not copied.
        """
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)

        os.utime(os.path.join(self.test_dir, 'subdir'), (0, DUMMY_TS))

        os.symlink(
            os.path.join(self.test_dir, 'subdir'),
            os.path.join(self.test_dir, 'subdir2', 'symlink')
        )
        os.symlink(
            os.path.join(self.test_dir, 'nonexist'),
            os.path.join(self.test_dir, 'subdir2', 'symlink2')
        )

        with self.app.test_client() as c:
            c.post('/deep/subdir2', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/clone',
            })

            mock_abort.assert_called_once_with(500, 'Fail to copy some files.')
            self.assertEqual(
                glob_files(os.path.join(self.test_dir, 'clone')),
                {
                    os.path.join(self.test_dir, 'clone', ''),
                    os.path.join(self.test_dir, 'clone', 'symlink'),
                    os.path.join(self.test_dir, 'clone', 'symlink', 'test.txt'),
                },
            )
            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir')},
                {'file': os.path.join(self.test_dir, 'clone', 'symlink')},
            )
            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'clone', 'symlink', 'test.txt')},
            )

            self.assertFalse(os.path.lexists(os.path.join(self.test_dir, 'deep', 'subdir', 'symlink2')))

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/nonexist', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(404, 'Source does not exist.')

    def test_beyond_root(self):
        """Target must be restricted within the root directory."""
        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '../deep/../../../deep/subdir2/test2.txt',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'subdir2', 'test2.txt')},
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_to_file(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir2', 'test2.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('你好 XYZ')

        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_dir_to_file(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir2', 'test2.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('你好 XYZ')

        with self.app.test_client() as c:
            c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2/test2.txt',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_file_to_dir(self):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)

        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                {'file': os.path.join(self.test_dir, 'subdir2', 'test.txt')},
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_to_dir_with_same_file(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir2', 'test.txt'), 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_file_to_dir_with_same_dir(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2', 'test.txt'), exist_ok=True)

        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_dir_to_dir(self):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)

        with self.app.test_client() as c:
            r = c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            self.assert_file_equal(
                {'file': os.path.join(self.test_dir, 'subdir')},
                {'file': os.path.join(self.test_dir, 'subdir2', 'subdir')},
            )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_dir_to_dir_with_same_file(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir2', 'subdir'), 'w'):
            pass

        with self.app.test_client() as c:
            c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_dir_to_dir_with_same_dir(self, mock_abort):
        os.makedirs(os.path.join(self.test_dir, 'subdir2', 'subdir'), exist_ok=True)

        with self.app.test_client() as c:
            c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_disk_to_zip_file(self):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/deep/newdir/test2.txt',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh:
                self.assert_file_equal(
                    {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                    {'zip': zh, 'filename': 'deep/newdir/test2.txt'},
                )
                self.assertEqual(zh.getinfo('deep/newdir/test2.txt').compress_type, zipfile.ZIP_DEFLATED)

    def test_disk_to_zip_dir(self):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/deep/newdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh:
                self.assert_file_equal(
                    {'file': os.path.join(self.test_dir, 'subdir')},
                    {'zip': zh, 'filename': 'deep/newdir/'},
                )
                self.assert_file_equal(
                    {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                    {'zip': zh, 'filename': 'deep/newdir/test.txt'},
                )
                self.assertEqual(zh.getinfo('deep/newdir/test.txt').compress_type, zipfile.ZIP_DEFLATED)

    @require_junction()
    @mock.patch('sys.stderr', io.StringIO())
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_disk_to_zip_junction_deep(self, mock_abort):
        """Copy junction entities with referenced directory content.

        - Broken symlinks are not copied.
        """
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)

        junction(
            os.path.join(self.test_dir, 'subdir'),
            os.path.join(self.test_dir, 'subdir2', 'junction'),
        )
        junction(
            os.path.join(self.test_dir, 'nonexist'),
            os.path.join(self.test_dir, 'subdir2', 'junction2'),
        )

        with self.app.test_client() as c:
            c.post('/deep/subdir2', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/clone',
            })

            mock_abort.assert_called_once_with(500, 'Fail to copy some files.')

            with zipfile.ZipFile(self.test_maff) as zh:
                self.assert_file_equal(
                    {'file': os.path.join(self.test_dir, 'subdir')},
                    {'zip': zh, 'filename': 'clone/junction/'},
                )
                self.assert_file_equal(
                    {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                    {'zip': zh, 'filename': 'clone/junction/test.txt'},
                )

                with self.assertRaises(KeyError):
                    zh.getinfo('clone/junction2/')

    @require_symlink()
    @mock.patch('sys.stderr', io.StringIO())
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_disk_to_zip_symlink_deep(self, mock_abort):
        """Copy symlink entities with referenced directory content.

        - Use stat of the symlink target.
        - Broken symlinks are not copied.
        """
        os.makedirs(os.path.join(self.test_dir, 'subdir2'), exist_ok=True)

        os.utime(os.path.join(self.test_dir, 'subdir'), (0, DUMMY_TS))

        os.symlink(
            os.path.join(self.test_dir, 'subdir'),
            os.path.join(self.test_dir, 'subdir2', 'symlink')
        )
        os.symlink(
            os.path.join(self.test_dir, 'nonexist'),
            os.path.join(self.test_dir, 'subdir2', 'symlink2')
        )

        with self.app.test_client() as c:
            c.post('/deep/subdir2', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/clone',
            })

            mock_abort.assert_called_once_with(500, 'Fail to copy some files.')

            with zipfile.ZipFile(self.test_maff) as zh:
                self.assert_file_equal(
                    {'file': os.path.join(self.test_dir, 'subdir')},
                    {'zip': zh, 'filename': 'clone/symlink/'},
                )
                self.assert_file_equal(
                    {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                    {'zip': zh, 'filename': 'clone/symlink/test.txt'},
                )

                with self.assertRaises(KeyError):
                    zh.getinfo('clone/symlink2/')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_disk_to_zip_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/nonexist', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/deep/newdir',
            })

            mock_abort.assert_called_once_with(404, 'Source does not exist.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_disk_to_zip_file_to_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir/index.html',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_disk_to_zip_dir_to_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir/index.html',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_disk_to_zip_file_to_dir(self):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                            {'zip': zh2, 'filename': 'subdir/test.txt'},
                        )

    def test_disk_to_zip_dir_to_dir(self):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            {'file': os.path.join(self.test_dir, 'subdir')},
                            {'zip': zh2, 'filename': 'subdir/subdir/'},
                        )
                        self.assert_file_equal(
                            {'file': os.path.join(self.test_dir, 'subdir', 'test.txt')},
                            {'zip': zh2, 'filename': 'subdir/subdir/test.txt'},
                        )

    def test_zip_to_disk_file(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/deep/newdir/index2.html',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh:
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'subdir/index.html'},
                    {'file': os.path.join(self.test_dir, 'deep', 'newdir', 'index2.html')},
                )

    def test_zip_to_disk_dir(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/deep/newdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh:
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'subdir/'},
                    {'file': os.path.join(self.test_dir, 'deep', 'newdir')},
                )
                self.assert_file_equal(
                    {'zip': zh, 'filename': 'subdir/index.html'},
                    {'file': os.path.join(self.test_dir, 'deep', 'newdir', 'index.html')},
                )

    def test_zip_to_disk_file_to_dir(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                self.assert_file_equal(
                    {'zip': zh1, 'filename': 'subdir/index.html'},
                    {'file': os.path.join(self.test_dir, 'subdir', 'index.html')},
                )

    def test_zip_to_disk_dir_to_dir(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                self.assert_file_equal(
                    {'zip': zh1, 'filename': 'subdir/'},
                    {'file': os.path.join(self.test_dir, 'subdir', 'subdir')},
                )
                self.assert_file_equal(
                    {'zip': zh1, 'filename': 'subdir/index.html'},
                    {'file': os.path.join(self.test_dir, 'subdir', 'subdir', 'index.html')},
                )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_disk_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/nonexist', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir2',
            })

            mock_abort.assert_called_once_with(404, 'Source does not exist.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_disk_file_to_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir/test.txt',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_disk_dir_to_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/subdir/test.txt',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_zip_to_zip_file(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/deep/newdir/index2.html',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            {'zip': zh1, 'filename': 'subdir/index.html'},
                            {'zip': zh2, 'filename': 'deep/newdir/index2.html'},
                        )

    def test_zip_to_zip_dir(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/deep/newdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            {'zip': zh1, 'filename': 'subdir/'},
                            {'zip': zh2, 'filename': 'deep/newdir/'},
                        )
                        self.assert_file_equal(
                            {'zip': zh1, 'filename': 'subdir/index.html'},
                            {'zip': zh2, 'filename': 'deep/newdir/index.html'},
                        )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_nonexist(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/nonexist', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/deep/newdir',
            })

            mock_abort.assert_called_once_with(404, 'Source does not exist.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_file_to_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir/index.html',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_dir_to_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir/index.html',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_zip_to_zip_file_to_dir(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir4',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            {'zip': zh1, 'filename': 'subdir/index.html'},
                            {'zip': zh2, 'filename': 'subdir4/index.html'},
                        )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_file_to_dir_with_same_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_file_to_dir_with_same_dir(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir/index.html', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir3',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    def test_zip_to_zip_dir_to_dir1(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            {'zip': zh1, 'filename': 'subdir/'},
                            {'zip': zh2, 'filename': 'subdir/subdir/'},
                        )
                        self.assert_file_equal(
                            {'zip': zh1, 'filename': 'subdir/index.html'},
                            {'zip': zh2, 'filename': 'subdir/subdir/index.html'},
                        )

    def test_zip_to_zip_dir_to_dir2(self):
        with self.app.test_client() as c:
            r = c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir2',
            })

            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

            with zipfile.ZipFile(self.test_maff) as zh1:
                with zh1.open('entry.maff') as fh:
                    with zipfile.ZipFile(fh) as zh2:
                        self.assert_file_equal(
                            {'zip': zh1, 'filename': 'subdir/'},
                            {'zip': zh2, 'filename': 'subdir2/subdir/'},
                        )
                        self.assert_file_equal(
                            {'zip': zh1, 'filename': 'subdir/index.html'},
                            {'zip': zh2, 'filename': 'subdir2/subdir/index.html'},
                        )

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_dir_to_dir_with_same_dir(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_zip_to_zip_dir_to_dir_with_same_file(self, mock_abort):
        with self.app.test_client() as c:
            c.post('/deep/archive.maff!/subdir', data={
                'token': token(c),
                'a': 'copy',
                'f': 'json',
                'target': '/deep/archive.maff!/entry.maff!/subdir4',
            })

            mock_abort.assert_called_once_with(400, 'Target already exists.')


class TestBackup(TestActions):
    def setUp(self):
        super().setUp()
        os.makedirs(os.path.join(self.test_dir, 'subdir'), exist_ok=True)
        with open(os.path.join(self.test_dir, 'subdir', 'test.txt'), 'w', encoding='UTF-8') as fh:
            fh.write('ABC 你好')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/deep/subdir/test.txt', query_string={
                'token': token(c),
                'a': 'backup',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """Require format."""
        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'a': 'backup',
            })

        mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/deep/subdir/test.txt', data={
                'a': 'backup',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    @mock.patch('webscrapbook.scrapbook.host.Host.backup')
    def test_file01(self, mock_func):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'ts': '20200102030405',
                'a': 'backup',
                'f': 'json',
            })

        mock_func.assert_called_once_with(
            os.path.join(self.test_dir, 'subdir', 'test.txt'),
            backup_dir=os.path.join(self.root, WSB_DIR, 'backup', '20200102030405'),
            move=False,
        )

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/json')
        self.assertEqual(r.json, {
            'data': '20200102030405',
        })

    @mock.patch('webscrapbook.scrapbook.host.Host.backup')
    def test_file02(self, mock_func):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'ts': '20200102030405',
                'move': '1',
                'a': 'backup',
                'f': 'json',
            })

        mock_func.assert_called_once_with(
            os.path.join(self.test_dir, 'subdir', 'test.txt'),
            backup_dir=os.path.join(self.root, WSB_DIR, 'backup', '20200102030405'),
            move=True,
        )

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/json')
        self.assertEqual(r.json, {
            'data': '20200102030405',
        })

    @mock.patch('webscrapbook.scrapbook.host.Host.backup')
    def test_file03(self, mock_func):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir/test.txt', data={
                'token': token(c),
                'ts': '20200102030405',
                'note': 'foo:bar:中文?',
                'a': 'backup',
                'f': 'json',
            })

        mock_func.assert_called_once_with(
            os.path.join(self.test_dir, 'subdir', 'test.txt'),
            backup_dir=os.path.join(self.root, WSB_DIR, 'backup', '20200102030405-foo_bar_中文_'),
            move=False,
        )

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/json')
        self.assertEqual(r.json, {
            'data': '20200102030405-foo_bar_中文_',
        })

    @mock.patch('webscrapbook.scrapbook.host.Host.backup')
    def test_directory01(self, mock_func):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir', data={
                'token': token(c),
                'ts': '20200102030405',
                'a': 'backup',
                'f': 'json',
            })

        mock_func.assert_called_once_with(
            os.path.join(self.test_dir, 'subdir'),
            backup_dir=os.path.join(self.root, WSB_DIR, 'backup', '20200102030405'),
            move=False,
        )

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/json')
        self.assertEqual(r.json, {
            'data': '20200102030405',
        })

    @mock.patch('webscrapbook.scrapbook.host.Host.backup')
    def test_directory02(self, mock_func):
        with self.app.test_client() as c:
            r = c.post('/deep/subdir', data={
                'token': token(c),
                'ts': '20200102030405',
                'move': '1',
                'a': 'backup',
                'f': 'json',
            })

        mock_func.assert_called_once_with(
            os.path.join(self.test_dir, 'subdir'),
            backup_dir=os.path.join(self.root, WSB_DIR, 'backup', '20200102030405'),
            move=True,
        )

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/json')
        self.assertEqual(r.json, {
            'data': '20200102030405',
        })


class TestUnbackup(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_method_check(self, mock_abort):
        """Require POST."""
        with self.app.test_client() as c:
            c.get('/', query_string={
                'token': token(c),
                'a': 'unbackup',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(405, valid_methods=['POST'])

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_format_check(self, mock_abort):
        """Require format."""
        with self.app.test_client() as c:
            c.post('/', data={
                'token': token(c),
                'a': 'unbackup',
            })

        mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.post('/', data={
                'a': 'unbackup',
                'f': 'json',
            })

            mock_abort.assert_called_once_with(400, 'Invalid access token.')

    @mock.patch('webscrapbook.scrapbook.host.Host.unbackup')
    def test_params01(self, mock_func):
        with self.app.test_client() as c:
            r = c.post('/', data={
                'token': token(c),
                'ts': '20200102030405',
                'a': 'unbackup',
                'f': 'json',
            })

        mock_func.assert_called_once_with(
            os.path.join(self.root, WSB_DIR, 'backup', '20200102030405'),
        )

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/json')
        self.assertEqual(r.json, {
            'data': '20200102030405',
        })

    @mock.patch('webscrapbook.scrapbook.host.Host.unbackup')
    def test_params02(self, mock_func):
        with self.app.test_client() as c:
            r = c.post('/', data={
                'token': token(c),
                'ts': '20200102030405',
                'note': 'foo:bar:中文?',
                'a': 'unbackup',
                'f': 'json',
            })

        mock_func.assert_called_once_with(
            os.path.join(self.root, WSB_DIR, 'backup', '20200102030405-foo_bar_中文_'),
        )

        self.assertEqual(r.status_code, 200)
        self.assertEqual(r.headers['Content-Type'], 'application/json')
        self.assertEqual(r.json, {
            'data': '20200102030405-foo_bar_中文_',
        })


class TestCache(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.get('/', query_string={'a': 'cache', 'f': 'sse'})

        mock_abort.assert_called_once_with(400, 'Invalid access token.')

    @mock.patch('webscrapbook.app.wsb_cache.generate', autospec=True,
                return_value=iter(()))
    def test_basic_sse(self, mock_func):
        with self.app.app_context(), self.app.test_client() as c:
            r = c.get('/', query_string={
                'a': 'cache', 'f': 'sse', 'token': token(c),
                'book': ['', 'book1'],
                'item[0]': ['_item1', '_item2'],
                'item[1]': ['book1_item1', 'book1_item2'],
                'item': ['item1', 'item2'],
                'no_lock': 1,
                'no_backup': 1,
                'fulltext': 1,
                'inclusive_frames': 1,
                'recreate': 1,
                'static_site': 1,
                'static_index': 1,
                'rss_root': 'http://example.com',
                'rss_item_count': 25,
                'locale': 'zh',
            })

            mock_func.assert_called_once_with(
                (wsb_app.host.root, wsb_app.host.config),
                book_items={
                    '': ['_item1', '_item2', 'item1', 'item2'],
                    'book1': ['book1_item1', 'book1_item2', 'item1', 'item2'],
                },
                lock=False,
                backup=False,
                fulltext=True,
                inclusive_frames=True,
                recreate=True,
                static_site=True,
                static_index=True,
                rss_root='http://example.com',
                rss_item_count=25,
                locale='zh',
            )
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/event-stream; charset=utf-8')
            self.assertEqual(self.parse_sse_objects(r.data.decode('UTF-8')), [
                ('complete', None),
            ])

    @mock.patch('webscrapbook.app.wsb_cache.generate', autospec=True,
                return_value=iter(()))
    def test_basic_json(self, mock_func):
        with self.app.app_context(), self.app.test_client() as c:
            r = c.post('/', data={
                'a': 'cache', 'f': 'json', 'token': token(c),
                'book': ['', 'book1'],
                'item[0]': ['_item1', '_item2'],
                'item[1]': ['book1_item1', 'book1_item2'],
                'item': ['item1', 'item2'],
                'no_lock': 1,
                'no_backup': 1,
                'fulltext': 1,
                'inclusive_frames': 1,
                'recreate': 1,
                'static_site': 1,
                'static_index': 1,
                'rss_root': 'http://example.com',
                'rss_item_count': 25,
                'locale': 'zh',
            })

            mock_func.assert_called_once_with(
                (wsb_app.host.root, wsb_app.host.config),
                book_items={
                    '': ['_item1', '_item2', 'item1', 'item2'],
                    'book1': ['book1_item1', 'book1_item2', 'item1', 'item2'],
                },
                lock=False,
                backup=False,
                fulltext=True,
                inclusive_frames=True,
                recreate=True,
                static_site=True,
                static_index=True,
                rss_root='http://example.com',
                rss_item_count=25,
                locale='zh',
            )
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

    @mock.patch('webscrapbook.app.stream_template', wraps=wsb_app.stream_template)
    @mock.patch('webscrapbook.app.wsb_cache.generate', autospec=True,
                return_value=iter(()))
    def test_basic_html(self, mock_func, mock_streamer):
        with self.app.app_context(), self.app.test_client() as c:
            r = c.post('/', data={
                'a': 'cache', 'token': token(c),
                'book': ['', 'book1'],
                'item[0]': ['_item1', '_item2'],
                'item[1]': ['book1_item1', 'book1_item2'],
                'item': ['item1', 'item2'],
                'no_lock': 1,
                'no_backup': 1,
                'fulltext': 1,
                'inclusive_frames': 1,
                'recreate': 1,
                'static_site': 1,
                'static_index': 1,
                'rss_root': 'http://example.com',
                'rss_item_count': 25,
                'locale': 'zh',
            }, buffered=True)

            mock_func.assert_called_once_with(
                (wsb_app.host.root, wsb_app.host.config),
                book_items={
                    '': ['_item1', '_item2', 'item1', 'item2'],
                    'book1': ['book1_item1', 'book1_item2', 'item1', 'item2'],
                },
                lock=False,
                backup=False,
                fulltext=True,
                inclusive_frames=True,
                recreate=True,
                static_site=True,
                static_index=True,
                rss_root='http://example.com',
                rss_item_count=25,
                locale='zh',
            )
            mock_streamer.assert_called_once_with(
                'cli.html',
                title='Indexing...',
                messages=mock.ANY,
                debug=False,
            )
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    @mock.patch('webscrapbook.app.wsb_cache.generate', autospec=True,
                return_value=iter((Info('critical', 'An unexpected error happened.'),)))
    def test_error_json(self, mock_func, mock_abort):
        with self.app.app_context(), self.app.test_client() as c:
            c.post('/', data={
                'a': 'cache', 'f': 'json', 'token': token(c),
                'book': ['', 'book1'],
                'item[0]': ['_item1', '_item2'],
                'item[1]': ['book1_item1', 'book1_item2'],
                'item': ['item1', 'item2'],
                'no_lock': 1,
                'no_backup': 1,
            })

            mock_abort.assert_called_once_with(500, 'An unexpected error happened.')


class TestCheck(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_token_check(self, mock_abort):
        """Require token."""
        with self.app.test_client() as c:
            c.get('/', query_string={'a': 'check', 'f': 'sse'})

        mock_abort.assert_called_once_with(400, 'Invalid access token.')

    @mock.patch('webscrapbook.app.wsb_check.run', autospec=True,
                return_value=iter(()))
    def test_basic_sse(self, mock_func):
        with self.app.app_context(), self.app.test_client() as c:
            r = c.get('/', query_string={
                'a': 'check', 'f': 'sse', 'token': token(c),
                'book': ['', 'id1'],
                'no_lock': 1,
                'no_backup': 1,
                'resolve_invalid_id': 1,
                'resolve_missing_index': 1,
                'resolve_missing_index_file': 1,
                'resolve_missing_date': 1,
                'resolve_older_mtime': 1,
                'resolve_toc_unreachable': 1,
                'resolve_toc_invalid': 1,
                'resolve_toc_empty_subtree': 1,
                'resolve_unindexed_files': 1,
                'resolve_absolute_icon': 1,
                'resolve_unused_icon': 1,
            })

            mock_func.assert_called_once_with(
                (wsb_app.host.root, wsb_app.host.config),
                book_ids=['', 'id1'],
                lock=False,
                backup=False,
                resolve_invalid_id=True,
                resolve_missing_index=True,
                resolve_missing_index_file=True,
                resolve_missing_date=True,
                resolve_older_mtime=True,
                resolve_toc_unreachable=True,
                resolve_toc_invalid=True,
                resolve_toc_empty_subtree=True,
                resolve_unindexed_files=True,
                resolve_absolute_icon=True,
                resolve_unused_icon=True,
            )
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/event-stream; charset=utf-8')
            self.assertEqual(self.parse_sse_objects(r.data.decode('UTF-8')), [
                ('complete', None),
            ])

    @mock.patch('webscrapbook.app.wsb_check.run', autospec=True,
                return_value=iter(()))
    def test_basic_json(self, mock_func):
        with self.app.app_context(), self.app.test_client() as c:
            r = c.post('/', data={
                'a': 'check', 'f': 'json', 'token': token(c),
                'book': ['', 'id1'],
                'no_lock': 1,
                'no_backup': 1,
                'resolve_invalid_id': 1,
                'resolve_missing_index': 1,
                'resolve_missing_index_file': 1,
                'resolve_missing_date': 1,
                'resolve_older_mtime': 1,
                'resolve_toc_unreachable': 1,
                'resolve_toc_invalid': 1,
                'resolve_toc_empty_subtree': 1,
                'resolve_unindexed_files': 1,
                'resolve_absolute_icon': 1,
                'resolve_unused_icon': 1,
            })

            mock_func.assert_called_once_with(
                (wsb_app.host.root, wsb_app.host.config),
                book_ids=['', 'id1'],
                lock=False,
                backup=False,
                resolve_invalid_id=True,
                resolve_missing_index=True,
                resolve_missing_index_file=True,
                resolve_missing_date=True,
                resolve_older_mtime=True,
                resolve_toc_unreachable=True,
                resolve_toc_invalid=True,
                resolve_toc_empty_subtree=True,
                resolve_unindexed_files=True,
                resolve_absolute_icon=True,
                resolve_unused_icon=True,
            )
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'application/json')
            self.assertEqual(r.json, {'data': None})

    @mock.patch('webscrapbook.app.stream_template', wraps=wsb_app.stream_template)
    @mock.patch('webscrapbook.app.wsb_check.run', autospec=True,
                return_value=iter(()))
    def test_basic_html(self, mock_func, mock_streamer):
        with self.app.app_context(), self.app.test_client() as c:
            r = c.post('/', data={
                'a': 'check', 'token': token(c),
                'book': ['', 'id1'],
                'no_lock': 1,
                'no_backup': 1,
                'resolve_invalid_id': 1,
                'resolve_missing_index': 1,
                'resolve_missing_index_file': 1,
                'resolve_missing_date': 1,
                'resolve_older_mtime': 1,
                'resolve_toc_unreachable': 1,
                'resolve_toc_invalid': 1,
                'resolve_toc_empty_subtree': 1,
                'resolve_unindexed_files': 1,
                'resolve_absolute_icon': 1,
                'resolve_unused_icon': 1,
            }, buffered=True)

            mock_func.assert_called_once_with(
                (wsb_app.host.root, wsb_app.host.config),
                book_ids=['', 'id1'],
                lock=False,
                backup=False,
                resolve_invalid_id=True,
                resolve_missing_index=True,
                resolve_missing_index_file=True,
                resolve_missing_date=True,
                resolve_older_mtime=True,
                resolve_toc_unreachable=True,
                resolve_toc_invalid=True,
                resolve_toc_empty_subtree=True,
                resolve_unindexed_files=True,
                resolve_absolute_icon=True,
                resolve_unused_icon=True,
            )
            mock_streamer.assert_called_once_with(
                'cli.html',
                title='Checking...',
                messages=mock.ANY,
                debug=False,
            )
            self.assertEqual(r.status_code, 200)
            self.assertEqual(r.headers['Content-Type'], 'text/html; charset=utf-8')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    @mock.patch('webscrapbook.app.wsb_check.run', autospec=True,
                return_value=iter((Info('critical', 'An unexpected error happened.'),)))
    def test_error_json(self, mock_func, mock_abort):
        with self.app.app_context(), self.app.test_client() as c:
            c.post('/', data={
                'a': 'check', 'f': 'json', 'token': token(c),
                'book': ['', 'id1'],
                'no_lock': 1,
                'no_backup': 1,
            })

            mock_abort.assert_called_once_with(500, 'An unexpected error happened.')


class TestUnknown(TestActions):
    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_unknown(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/', query_string={'a': 'unkonwn'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')

    @mock.patch('webscrapbook.app.abort', wraps=wsb_app.abort)
    def test_unknown_json(self, mock_abort):
        with self.app.test_client() as c:
            c.get('/', query_string={'a': 'unkonwn', 'f': 'json'})
            mock_abort.assert_called_once_with(400, 'Action not supported.')


if __name__ == '__main__':
    unittest.main()
